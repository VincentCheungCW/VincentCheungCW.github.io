<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Something True</title>
    <url>/2020/about/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>现居北京。</p>
</blockquote>
<blockquote>
<p>后端开发工程师，主修 Java ，辅修 Python、Go ，会点 React。</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>电脑DIY入门级爱好者，组装过 Hackintosh。</p>
</blockquote>
<blockquote>
<p>电影发烧友。</p>
</blockquote>
<blockquote>
<p>爱听 Hiphop 和 R&amp;B。</p>
</blockquote>
<blockquote>
<p>喜欢一切美好的事物。</p>
</blockquote>
<br/>

<p>豆瓣： <a href="https://www.douban.com/people/59143830/">蒋鹿丸</a><br>GitHub： <a href="https://github.com/VincentCheungCW">VincentCheungCW</a></p>
<br/>


<!-- ![avatar.jpg](https://i.loli.net/2019/12/02/Hw5WJIMKzi1YrU8.jpg) -->

<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnhogd2xtej30k10k1abb.jpg" alt="avatar" width="300" style="border-radius:50%"/>]]></content>
  </entry>
  <entry>
    <title>2019年我最喜欢的电影（一）</title>
    <url>/2020/favFilms2019-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer" />

<br/>

<p>¹「宠儿」 The Favourite</p>
<p>导演: 欧格斯·兰斯莫斯<br>国家: 爱尔兰/英国/美国</p>
<p>年度最佳观影体验之一，绝对有趣的电影。<br>「龙虾」导演的新作，讲述了安妮女王的绣榻野史，近年最好的古装片，三位女主角给出了绝佳的表演。加上伦勃朗式的光影，幽默的对白和章回体结构，夸张的造型，怪异的配乐，合力制造出这一部风格独绝的英宫剧。</p>
<a id="more"></a>

<br/>

<p>²「地球最后的夜晚」</p>
<p> 导演: 毕赣<br> 国家: 中国 / 法国</p>
<p> 年度最佳观影体验之三，「路边野餐」技术大升级。<br> 看完「地球最后的夜晚」之后我又重刷一遍「路边野餐」，「路」真的怎么夸都不为过，它的惊艳程度对我而言甚至大于贾樟柯的「小武」。「地」复用了「路」的故事结构和想法，大体上只是一次技术升级，它的创意和表达反而是不及「路」的。本片带给我好的体验主要来自它令人激动的配乐和摄影，此外，文本上与「路」的呼应也似乎令前作更加完整。毕赣仍然是年轻一代中最有可能成为大师的那个，希望他在下部作品中跳出凯里。</p>
 <br/>

<p>³「此房是我造」 The House That Jack Built</p>
<p>  导演: 拉斯·冯·提尔<br>  国家: 丹麦/法国/德国/瑞典</p>
<p>  园子温的电影偶像是拉斯·冯·提尔，两位都是鬼才怪才，当然拉斯·冯·提尔更具文学性。该片极为成功地塑造了一位连环杀手形象，故事大胆到只有拉斯·冯·提尔会这样拍。最后的十几分钟结尾有点拖后腿，不然就是神作。</p>
  <br/>

<p>⁴「不留痕迹」 Leave No Trace</p>
<p> 导演: 黛布拉·格兰尼克<br> 国家: 美国</p>
<p> 反常规反套路的叙事。绝不交待来龙去脉，只关注于事件造成的影响。这是一部会呼吸的影片，细节丰富，讲道理绝不靠说教。小女主表演非常有灵气。</p>
 <br/>

<p>⁵「幸福的拉扎罗」 Lazzaro felice</p>
<p> 导演: 阿莉切·罗尔瓦赫尔<br> 国家: 意大利/瑞士/法国/德国</p>
<p> 很高级的一部影片，但这种高级主要来自于电影文本。拉扎罗会成为一个永恒的艺术形象。</p>
 <br/>

]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>2019</tag>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>2019年我最喜欢的电影（二）</title>
    <url>/2020/favFilms2019-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer" />

<br/>

<p>¹「罗马」 Roma</p>
<p> 导演: 阿方索·卡隆<br> 国家: 墨西哥/美国</p>
<p> 年度最佳观影体验之二，细腻流畅的女性主义史诗。<br> 很“侯孝贤”的一部电影，镜头语言无懈可击。关于故事怎样讲得平淡克制又暗涌澎湃，阿方索·卡隆给出了很好的示范。他的前作「地心引力」是我认为近十年最好的太空科幻电影，而「罗马」很可能帮他再次拿下奥斯卡最佳导演，果真如此的话，将是“墨西哥三杰”近6年内第5次喜提奥斯卡。</p>
 <br/>
 
<a id="more"></a>

<p>²「燃烧」 버닝</p>
<p> 导演: 李沧东<br> 国家: 韩国</p>
<p> 刘亚仁的表演是这部影片的精华所在，他的特写镜头的丰富意涵包含甚至超越了影片中所有对阶级意识或虚无主义的暗示。</p>
 <br/>

<p>³「佛罗里达乐园」 The Florida Project</p>
<p>  导演：肖恩·贝克<br>  国家：美国</p>
<p>  实际是2017年的电影，2018年才看到。如果与「小偷家族」二选一的话我会毫不犹豫地选这一部，该片饱含着「小偷家族」所缺少的那种生命力。</p>
  <br/>

<p>⁴「绿皮书」 Green Book</p>
<p> 导演: 彼得·法雷利<br> 国家: 美国</p>
<p> 又名“蒂凡尼男孩”哈哈。该片剧本是好莱坞叙事技巧的绝佳范例。阿里很可能凭本片连庄奥斯卡最佳男配。</p>
 <br/>

<p>⁵「巴斯特·斯克鲁格斯的歌谣」 The Ballad of Buster Scruggs</p>
<p> 导演: 伊桑·科恩 / 乔尔·科恩<br> 国家: 美国</p>
<p> 科恩兄弟的短篇小说集，六个短片，有荒诞可笑也有悲酸无奈，高开低走，好在最后一个故事收得不错。</p>
 <br/>

]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>2019</tag>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 0 - 初识Python</title>
    <url>/2020/python0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer" />

<br/>
<div align="center">    
    <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkhtk5rq3cj30dw04474e.jpg"
    width="500px">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;color: #999;padding: 2px;">
    Python 的双头蛇 logo
    </div>
</div>
<br/>

<a id="more"></a>


<hr>
<br/>

<h3 id="谁创造了Python？"><a href="#谁创造了Python？" class="headerlink" title="谁创造了Python？"></a>谁创造了Python？</h3><p>Python的创始人为Guido van Rossum，当时他在阿姆斯特丹的荷兰数学和计算机科学研究学会工作。1989年的圣诞节期间，Guido为了打发时间而创造了Python。新编程语言之所以命名为Python，是因为他是BBC电视剧——<a href="https://movie.douban.com/subject/1485976/"><code>Monty Python&#39;s Flying Circus</code></a>的忠实粉丝。</p>
<div class="douban-card-block">
	<a class="douban-card" href="https://movie.douban.com/subject/1485976">
		<div class="douban-card-bgimg" style="background-image: url('https://images.weserv.nl/?url=https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2254037897.jpg');"></div>
		<div class="douban-card-left">
			<div class="douban-card-img" style="background-image: url('https://images.weserv.nl/?url=https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2254037897.jpg');"></div>
		</div>
		<div class="douban-card-right">
			<div class="douban-card-item"><span>电影名: </span><strong>巨蟒剧团之飞翔的马戏团第一季MontyPython&#39;sFlyingCircusSeason1(1969)</strong></div>
			<div class="douban-card-item"><span>导演: </span><span>约翰·霍华德·戴维斯/伊恩·迈克纳顿</span></div>
			<div class="douban-card-item"><span>主演: </span><span>格雷厄姆·查普曼/约翰·克立斯</span></div>
			<div class="douban-card-item"><span>上映时间: </span><span></span></div>
			<div class="douban-card-item"><span>评分: </span><span>9.4</span></div>
		</div>
	</a>
</div>
<style>
	.douban-card-block {
		display: flex;
		justify-content: center;
		align-items: center;
		width: 100%;
		max-height: 400px;
	}
	.douban-card {
		display: flex;
		margin: 30px 10px;
		padding: 15px;
		border-radius: 10px;
		position: relative;
		justify-content: center;
		align-items: center;
		overflow: hidden;
		color: antiquewhite;
		text-decoration: none;
	}
	.douban-card:hover {
		text-decoration: none;
	}
	.douban-card-bgimg {
		position: absolute;
		width: 115%;
		height: 115%;
		filter: blur(15px) brightness(0.6);
		background-size: 100%;
		background-position: center;
		background-repeat: no-repeat;
	}
	.douban-card-img {
		position: relative;
		height: 130px;
		width: 80px;
		background-size: 100%;
		background-position: center;
		background-repeat: no-repeat;
	}
	.douban-card-img {
		position: relative;
		height: 130px;
		width: 80px;
	}
	.douban-card-left {
		position: relative;
		display: flex;
		flex-direction: column;
		align-items: center;
	}
	.douban-card-right {
		position: relative;
		display: flex;
		flex-direction: column;
		margin-left: 12px;
		font-size: 16px;
		font-family: 'Courier New', Courier, monospace;
		line-height: 1.3;
		color: antiquewhite;
	}
	.douban-card-item {
		margin-top: 4px;
	}
</style>
<br/>

<div  align="center">    
    <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://tva1.sinaimg.cn/large/008eGmZEly1gnjntwxibuj30z20lsb29.jpg"
    width="700px">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;color: #999;padding: 2px;">
    荷兰人Guido
    </div>
</div>
<br/>

<p>Python 第一个公开版发行于 1991 年。Python 3.0于2008年12月3日发布，它对语言做了较大修订而不能完全后向兼容。</p>
<p>2020 年 1 月 1 日，官方宣布 停止 Python 2 的更新，Python2会逐步被Python3替代。</p>
<p><strong>Python 越来越火爆</strong></p>
<p>在2007年、2010年和2018年Python三次被选为年度编程语言。自从2003年，Python始终位列<a href="https://www.wikiwand.com/en/TIOBE_Programming_Community_Index">TIOBE </a>前十最流行编程语言榜单。最新的排名（2020年11月），Python已冲到第二名的位置（居于C之后，Java之前）。</p>
<hr>
<br/>

<h3 id="Life-is-short-use-Python-…-for-what"><a href="#Life-is-short-use-Python-…-for-what" class="headerlink" title="Life is short, use Python … for what?"></a>Life is short, use Python … for what?</h3><ol>
<li><strong>Web 应用开发</strong></li>
</ol>
<p>Python 在 Web 开发领域被广泛使用，产生了 <strong>Django</strong>、<strong>Flask</strong>、<strong>Tornado</strong> 等 Web 开发框架。得益于其简洁的语法和动态语言特性，Python 的开发效率很高，因而深受创业团队的青睐。</p>
<p>一些将 Python 作为主要开发语言的知名互联网企业：</p>
<ul>
<li>豆瓣</li>
<li>知乎</li>
<li>Instagram</li>
</ul>
<ol start="2">
<li><strong>网络爬虫</strong></li>
</ol>
<p>泛指从互联网采集数据。尽管很多语言都可以编写爬虫，但灵活的 Python 无疑也是当前的首选。基于 Python 的爬虫框架 <strong>Scrapy</strong> 也很受欢迎。</p>
<p>这个星球上最大的“爬虫”公司 – <strong>Google</strong> 一直力推 Python，不仅在公司内部大量使用 Python，也为开发社区做了巨大贡献。就连 Python 之父 <strong>Guido van Rossum</strong> 也曾在 Google 工作七年。</p>
<ol start="3">
<li><strong>数据分析</strong></li>
</ol>
<p>当通过爬虫获取了海量数据之后，需要对数据进行清洗、去重、存储、展示、分析，在这方面 Python 有许多优秀的类库：<strong>NumPy</strong>、<strong>Pandas</strong>、<strong>Matplotlib</strong>， 可以让你的数据分析工作事半功倍。</p>
<ol start="4">
<li><strong>人工智能</strong></li>
</ol>
<p>Python 在人工智能领域内的<strong>数据挖掘</strong>、<strong>机器学习</strong>、<strong>神经网络</strong>、<strong>深度学习</strong>等方面都是主流的编程语言，得到广泛的支持和应用。</p>
<hr>
<br/>

<h3 id="Python好在哪？"><a href="#Python好在哪？" class="headerlink" title="Python好在哪？"></a>Python好在哪？</h3><p>Python 是一种兼具 <em>简单</em> 与 <em>功能强大</em> 的编程语言。Guido给Python的定位是<strong>优雅</strong>、<strong>明确</strong>、<strong>简单</strong>，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常复杂的程序。</p>
<ul>
<li>简单、易学 – Python 是一种代表极简主义思想的语言。它使你专注于解决问题而非拘泥于语法与结构。</li>
<li>免费、开源 – 这是为什么 Python 如此优秀的原因之一——它是由一群希望看到一个更加优秀的 Python 的人创造并经常改进着的。</li>
<li>丰富的类库 – Python 标准库已经很庞大，但除了标准库以外，还有许多其他高质量的第三方库，如 wxPython、Twisted 和 Python 图像库等等。</li>
<li>规范的代码 – Python 采用强制缩进的方式使得代码具有极佳的可读性。</li>
</ul>
<p>总的来说，Python的哲学就是简单优雅，尽量写容易看明白的代码，尽量写少的代码。如果一个资深程序员向你炫耀他写的晦涩难懂、动不动就几万行的代码，你可以尽情地嘲笑他。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 02 - Python 基础之基础</title>
    <url>/2020/python02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer" />


<h3 id="一-Python书写规范"><a href="#一-Python书写规范" class="headerlink" title="一. Python书写规范"></a>一. Python书写规范</h3><h4 id="大小写敏感"><a href="#大小写敏感" class="headerlink" title="大小写敏感"></a>大小写敏感</h4><p>首先要注意的是 Python 语言是大小写敏感的，如果写错了大小写，程序会报错。</p>
<h4 id="每行一个语句"><a href="#每行一个语句" class="headerlink" title="每行一个语句"></a>每行一个语句</h4><p>Python 鼓励每一行使用一句独立语句从而使得代码更加可读。<br>不同于C、Java等其他语言使用分号（；）区分多条语句，Python中利用换行区分多条语句。<br>举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">5</span></span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure>
<p>上面的两条语句必须写在两行里，若写成下面这样，程序是无法识别的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">5</span>  print(i)</span><br></pre></td></tr></table></figure>
<p>当然写在一行里用分号分隔也可以，但Python中一般不建议出现分号。实际上，我<em>从未</em>在 Python 程序中见过一个分号。</p>
<h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><p>放置在一起的语句<em>必须</em>拥有相同的缩进。每一组这样的语句被称为 <em>块（block）</em>。我们将会在后文章节的案例中了解块这一概念是多么重要。</p>
<p>现在只需要记住一件事：错误的缩进可能会导致错误。下面是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">5</span></span><br><span class="line"><span class="comment"># 下面行首有一个空格，运行的话会报错</span></span><br><span class="line">print(<span class="string">&#x27;Value is&#x27;</span>, i)</span><br><span class="line">print(<span class="string">&#x27;I repeat, the value is&#x27;</span>, i)</span><br></pre></td></tr></table></figure>
<p>当你运行这一程序时，你将得到如下错误：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  File <span class="string">&quot;whitespace.py&quot;</span>, line <span class="number">3</span></span><br><span class="line">    print(<span class="string">&#x27;Value is&#x27;</span>, i)</span><br><span class="line">    ^</span><br><span class="line">IndentationError: unexpected indent</span><br><span class="line"><span class="comment"># 缩进错误：意外缩进</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>如何缩进</strong></p>
<p>使用四个空格来缩进，这是来自 Python 语言官方的建议。好的编辑器会<strong>自动为你完成这一工作</strong>。请确保你在缩进中使用数量一致的空格，否则你的程序将不会运行，或引发不期望的行为。</p>
</blockquote>
<h4 id="Python-标识符"><a href="#Python-标识符" class="headerlink" title="Python 标识符"></a>Python 标识符</h4><p>标识符是语言中允许作为名字的有效字符串集合。</p>
<p>合法的 Python 标识符，需要遵守如下规定：</p>
<ul>
<li>第一个字符必须是字母或下划线（_）</li>
<li>剩下的字符可以是字母和数字或下划线</li>
<li>大小写敏感</li>
<li>不能是 Python 的关键字，例如 def、class 就不能作为标识符</li>
</ul>
<p>以下划线开头的标识符是有特殊意义的。以单下划线开头 <code>_foo</code> 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 <code>from xxx import *</code> 而导入。</p>
<p>以双下划线开头的 <code>__foo</code> 代表类的私有成员，以双下划线开头和结尾的 <code>__foo__</code> 代表 Python 里特殊方法专用的标识，如 <code>__init__()</code> 代表类的构造函数。</p>
<h4 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h4><p>Python 语句中一般以新行作为为语句的结束符。但是我们可以使用斜杠（ \）将一行的语句分为多行显示，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total = item_one + item_two + item_three</span><br></pre></td></tr></table></figure>

<p>语句中包含[], {} 或 () 括号就不需要使用多行连接符。如下实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">days = [<span class="string">&#x27;Monday&#x27;</span>, <span class="string">&#x27;Tuesday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Thursday&#x27;</span>, <span class="string">&#x27;Friday&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="注释（comment）"><a href="#注释（comment）" class="headerlink" title="注释（comment）"></a>注释（comment）</h4><p><em>注释</em> 是一行以 <code>#</code> 号开头的文字，其主要用作写给程序读者看的说明性文字。</p>
<p>举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;hello world&#x27;</span>)  <span class="comment"># 使用 print 函数输出字符串</span></span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 print 函数输出字符串</span></span><br><span class="line">print(<span class="string">&#x27;hello world&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>你应该在你的程序中尽可能多地写注释，这样做对你的程序的读者来说非常有用，他们可以很容易地理解你的每条语句的用意。这个人可以是六个月后的你！</p>
<hr>
<br/>

<h3 id="二-输入和输出"><a href="#二-输入和输出" class="headerlink" title="二. 输入和输出"></a>二. 输入和输出</h3><h4 id="输出-print"><a href="#输出-print" class="headerlink" title="输出: print()"></a>输出: print()</h4><p>我们在前面已经学习了，用<code>print()</code>在括号中加上字符串，就可以向屏幕上输出指定的文字。<code>print()</code>函数也可以接受多个字符串，用逗号隔开，就可以连成一串输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;好风频借力，&#x27;</span>, <span class="string">&#x27;送我上青云。&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>print()</code>会依次打印每个字符串，遇到逗号“,”会输出一个空格。</p>
<p>如果想一次输出多行，怎么办呢？可以这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;好风频借力，\n送我上青云。&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>\n</code>是转义字符，表示换行。常用的转义字符还有：</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><code>\\</code></td>
<td>代表一个反斜线字符<code>\</code></td>
</tr>
<tr>
<td><code>\&#39;</code></td>
<td>代表一个单引号字符<code>&#39;</code></td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>代表一个双引号字符<code>&quot;</code></td>
</tr>
</tbody></table>
<h4 id="输入-input"><a href="#输入-input" class="headerlink" title="输入: input()"></a>输入: input()</h4><p>现在，你已经可以用<code>print()</code>输出你想要的结果了。但是，如果要让用户从电脑输入一些字符怎么办？Python提供了一个<code>input()</code>方法，可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;请输入用户名:&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序运行到<code>input()</code>时会停下来等待用户输入，这时，你可以输入任意字符，然后按回车后完成输入。输入完成后，不会有任何提示，Python交互式命令行又回到<code>&gt;&gt;&gt;</code>状态了。那我们刚才输入的内容到哪去了？答案是存放到<code>name</code>变量里了。我们可以打印出<code>name</code>查看变量内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;Hello&#x27;</span>, name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<br/>


<h3 id="三-如何编写和运行-Python-程序"><a href="#三-如何编写和运行-Python-程序" class="headerlink" title="三. 如何编写和运行 Python 程序"></a>三. 如何编写和运行 Python 程序</h3><h4 id="使用文本编辑器"><a href="#使用文本编辑器" class="headerlink" title="使用文本编辑器"></a>使用文本编辑器</h4><p>编写和运行 Python 程序的标准步骤如下：</p>
<ol>
<li>打开你的编辑器（例如Sublime Text）</li>
<li>输入案例中给出的代码</li>
<li>以给定的文件名将其保存成文件</li>
<li>在命令行中通过命令 <code>python xxx.py</code> 来运行程序。（macOS使用命令<code>python3 xxx.py</code>）</li>
</ol>
<h4 id="使用集成开发环境（IDE）"><a href="#使用集成开发环境（IDE）" class="headerlink" title="使用集成开发环境（IDE）"></a>使用集成开发环境（IDE）</h4><ol>
<li>在Pycharm中编写代码</li>
<li>检查没有语法错误后点击鼠标右键 -&gt; Run，运行程序（有语法错误的话相应代码会标红）</li>
</ol>
<p>推荐使用Pycharm编写Python代码，会令你的开发工作轻松许多。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 01 - 本地安装Python</title>
    <url>/2020/python01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer" />

<p>因为Python是跨平台的，也就是说它可以运行在Windows、Mac和各种Linux/Unix系统上。在Windows上写的Python程序，放到Linux上也是能够运行的。要开始学习Python编程，首先就得把Python安装到你的电脑里。安装后，你会得到Python解释器（就是负责运行Python程序的），一个命令行交互环境，还有一个简单的集成开发环境。这里我们安装的是 3.9.0 版本的Python。</p>
<a id="more"></a>

<p>建议大家直接去官网下载最新版本的安装包，官网地址：<a href="https://www.python.org/">https://www.python.org/</a>。也可以用我提供给大家的安装包，安装包的位置：tools/necessary。</p>
<hr>
<br/>


<h3 id="一-Windows-系统下的安装配置"><a href="#一-Windows-系统下的安装配置" class="headerlink" title="一. Windows 系统下的安装配置"></a>一. Windows 系统下的安装配置</h3><p>windows 系统对应的安装包名字为python-3.9.0.exe，下载完后，双击进入下图安装页面，记得勾上Add Python 3.9 to PATH，然后点 「Install Now」 即可完成安装。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2136918-2bf6591f0a12e80b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Python安装.png"></p>
<h4 id="验证是否安装成功"><a href="#验证是否安装成功" class="headerlink" title="验证是否安装成功"></a>验证是否安装成功</h4><p>安装完成后，打开命令提示符（即cmd.exe），敲入 python ，出现Python版本信息，证明 Python 安装成功了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2136918-817c22f802e8cfce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行python.png"></p>
<p>命令提示符最后一行 <code>&gt;&gt;&gt;</code> 表示我们已经在 Python 交互环境中了，可以输入任何 Python 代码，回车后会立刻得到执行结果，试着输入下面代码，然后按回车看看吧。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">print (100 / 3.1415926)</span><br></pre></td></tr></table></figure>
<hr>
<br/>


<h3 id="二-macOS下的安装配置"><a href="#二-macOS下的安装配置" class="headerlink" title="二. macOS下的安装配置"></a>二. macOS下的安装配置</h3><p>Mac系统安装Python就更简单了，安装包名字为python-3.9.0-macosx10.9.pkg，双击安装即可。</p>
<p>这里还有另外一种方法，如果你安装了Homebrew，直接通过命令<code>brew install python3</code>安装即可。（如果你没有读懂这句话，说明你不需要它）</p>
<h4 id="验证是否安装成功-1"><a href="#验证是否安装成功-1" class="headerlink" title="验证是否安装成功"></a>验证是否安装成功</h4><p>安装完成后，打开终端.app（或者iTerm），敲入 <code>python3</code> ，出现Python版本信息，证明 Python 安装成功了。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnkpi1g3dlj31ky0ciacn.jpg" alt="运行python.png"></p>
<p>注意：终端里输入<code>python</code>得到的是macOS系统预装的Python 2.7.16 版本，输入<code>python3</code>才会进入我们安装的版本。</p>
<p>Python2已经是过时的版本，而macOS之所以预装了这个版本，是为了兼容一些历史软件。我们一般使用Python3。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnkpcw31i7j31ky0l2tcr.jpg" alt="macOS 预装了 Python2"></p>
<p>这样我们输入<code>python3</code>后就进入 Python 交互环境中了，可以输入任何 Python 代码，回车后会立刻得到执行结果，试着输入下面代码，然后按回车看看吧。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">print (&quot;玉在椟中求善价，钗于奁内待时飞。&quot;)</span><br></pre></td></tr></table></figure>

<p>这样我们的Python环境就搭建完成了，第一个 Python 程序也成功运行了，是不是很简单。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 03 - Python 变量与数据类型</title>
    <url>/2020/python03/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer" />



<h3 id="变量（Variable）"><a href="#变量（Variable）" class="headerlink" title="变量（Variable）"></a>变量（Variable）</h3><p>变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p>
<p>变量在程序中用一个变量名表示，在 Python 中 变量命名规定，必须是大小写英文，数字和 下划线<code>(_)</code>的组合，并且不能用数字开头。比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>变量<code>a</code>是一个整数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t_007 = <span class="string">&#x27;T007&#x27;</span></span><br></pre></td></tr></table></figure>
<p>变量<code>t_007</code>是一个字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Answer = <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>变量<code>Answer</code>是一个布尔值<code>True</code>。</p>
<p>在 Python 中，变量就是变量，它没有类型（或者称为动态类型），我们所说的”类型”是变量所指的内存中对象的类型。</p>
<h4 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h4><p>在 Python 中，<strong>等号 = 是赋值语句</strong>，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;neo&quot;</span></span><br></pre></td></tr></table></figure>
<p>上述代码声明了一个变量，变量名为：name, 变量 name 的值为”neo”。</p>
<h4 id="多个变量赋值"><a href="#多个变量赋值" class="headerlink" title="多个变量赋值"></a>多个变量赋值</h4><p>Python 允许你同时为多个变量赋值。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>以上实例，创建一个整型对象，值为 1，三个变量被赋予相同的数值。</p>
<p>您也可以为多个对象指定多个变量。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;neo&quot;</span></span><br></pre></td></tr></table></figure>
<p>以上实例，两个整型对象 1 和 2 的分配给变量 a 和 b，字符串对象 “neo” 分配给变量 c。</p>
<hr>
<br/>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="数字（Number）"><a href="#数字（Number）" class="headerlink" title="数字（Number）"></a>数字（Number）</h4><p>数字主要分为两种类型——整数（Integer）与浮点数（Float）。</p>
<p>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，<code>1.23e9</code>和<code>12.3e8</code>是完全相等的。</p>
<h4 id="布尔型（Bool）"><a href="#布尔型（Bool）" class="headerlink" title="布尔型（Bool）"></a>布尔型（Bool）</h4><p>一个布尔值只有<code>True</code>、<code>False</code>两种状态，要么是<code>True</code>，要么是<code>False</code>。试试下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> &gt; <span class="number">2</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> + <span class="number">2</span> == <span class="number">5</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h4 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h4><p>简单来说，字符串就是一串词汇。</p>
<p>严谨一点，字符串是以单引号’’或双引号””括起来的任意文本，请注意，<code>&#39;&#39;</code>或<code>&quot;&quot;</code>本身只是一种表示方式，不是字符串的一部分。单引号和双引号是等价的。</p>
<p>几乎所有 Python 程序都会使用到字符串，所以，take care。</p>
<h5 id="r-string"><a href="#r-string" class="headerlink" title="r-string"></a>r-string</h5><p>Python用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串为raw string，可以自己试试看有何不同：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">r&#x27;Hamilton said: &quot;In New York you can be a new man.&quot;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;&#x27;&#x27;Hamilton said: &quot;In New York you can be a new man.&quot;&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Hamilton said: &quot;</span>In New York you can be a new man.<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>上面前两种写法都是正确的，第三种不符合语法规范，会报错。</p>
<h5 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a>format方法</h5><p>格式化字符串。</p>
<p>运行下面的语句看看结果吧 ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">output = <span class="string">&#x27;亲爱的&#123;&#125;你好！你&#123;&#125;月的话费是&#123;&#125;元，余额是&#123;&#125;元。&#x27;</span></span><br><span class="line"></span><br><span class="line">ella = <span class="string">&#x27;Ella&#x27;</span></span><br><span class="line">month = <span class="string">&#x27;11&#x27;</span></span><br><span class="line">bill = <span class="number">120</span></span><br><span class="line">remain = <span class="number">300</span></span><br><span class="line">print(output.<span class="built_in">format</span>(ella, month, bill, remain))</span><br><span class="line"></span><br><span class="line">mike = <span class="string">&#x27;Mike&#x27;</span></span><br><span class="line">bill = <span class="number">150</span></span><br><span class="line">remain = <span class="number">900</span></span><br><span class="line">print(output.<span class="built_in">format</span>(mike, month, bill, remain))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">Swaroop was 20 years old when he wrote this book</span><br><span class="line">Why is Swaroop playing with that python?</span><br></pre></td></tr></table></figure>
<p><strong>它是如何工作的</strong></p>
<p>一个字符串可以使用某些特定的格式（Specification），随后，<code>format</code> 方法将被调用，使用这一方法中与之相应的参数替换这些格式。</p>
<p>Python 中 <code>format</code> 方法所做的事情便是将每个参数值替换至格式所在的位置。</p>
<h5 id="操作符"><a href="#操作符" class="headerlink" title="% 操作符"></a>% 操作符</h5><p>Python中内置的%操作符可用于格式化字符串，控制字符串的呈现格式。</p>
<p>格式化字符串时，Python使用一个字符串作为模板。模板中有格式符，这些格式符为真实值预留位置，并说明真实数值应该呈现的格式。Python用一个<code>tuple</code>将多个值传递给模板，每个值对应一个格式符。</p>
<p>比如下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;I&#x27;m %s. I&#x27;m %d year old&quot;</span> % (<span class="string">&#x27;Jaden&#x27;</span>, <span class="number">20</span>))</span><br></pre></td></tr></table></figure>
<p>上面的例子中，</p>
<p><code>&quot;I&#39;m %s. I&#39;m %d year old&quot;</code> 为我们的模板。%s为第一个格式符，表示一个字符串。%d为第二个格式符，表示一个整数。<code>(&#39;Jaden&#39;, 20)</code>的两个元素’Jaden’和20为替换%s和%d的真实值。在模板和tuple之间，有一个%号分隔，它代表了格式化操作。</p>
<p>整个<code>&quot;I&#39;m %s. I&#39;m %d year old&quot; % (&#39;Jaden&#39;, 20)</code>实际上构成一个字符串表达式。我们可以像一个正常的字符串那样，将它赋值给某个变量。比如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&quot;I&#x27;m %s. I&#x27;m %d year old&quot;</span> % (<span class="string">&#x27;Jaden&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p> <strong>格式符</strong></p>
<p>格式符为真实值预留位置，并控制显示的格式。格式符可以包含有一个类型码，用以控制显示的类型，如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">%s  字符串</span><br><span class="line"></span><br><span class="line">%d  十进制整数</span><br><span class="line"></span><br><span class="line">%f  浮点数</span><br></pre></td></tr></table></figure>

<p>可以用如下的方式，对格式进行进一步的控制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">%[(name)][flags][width].[precision]typecode</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(name)为命名</p>
<p>flags可以有+,-,’ ‘或0。+表示右对齐。-表示左对齐。’ ‘为一个空格，表示在正数的左侧填充一个空格，从而与负数对齐。0表示使用0填充。</p>
<p>width表示显示宽度</p>
<p>precision表示小数点后精度</p>
<p>比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;%04d&quot;</span> % <span class="number">5</span>)</span><br><span class="line">print(<span class="string">&quot;%6.3f&quot;</span> % <span class="number">2.3</span>)</span><br></pre></td></tr></table></figure>
<p>除上面列举的几种数据类型外，Python还提供了List（列表）、Tuple（元组）、Sets（集合）、Dictionary（字典）等多种数据类型，并且允许用户创建自定义数据类型，我们后面会继续讲到。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 04 - Python 运算符</title>
    <url>/2020/python04/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer" />


<p>Python的运算符和其他语言类似，这里我们只做简单介绍，因为很多高级功能基本用不到，真正用到时再去Google一下也不迟，实际上现在程序员的工作大多是<code>面向Google</code>的编程，因为知识爆炸性增长，脑袋是记不下的。</p>
<h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">1</span>+<span class="number">9</span>)      <span class="comment"># 加法</span></span><br><span class="line"></span><br><span class="line">print(<span class="number">1.3</span>-<span class="number">4</span>)    <span class="comment"># 减法</span></span><br><span class="line"></span><br><span class="line">print(<span class="number">3</span>*<span class="number">5</span>)      <span class="comment"># 乘法</span></span><br><span class="line"></span><br><span class="line">print(<span class="number">4.5</span>/<span class="number">1.5</span>)  <span class="comment"># 除法</span></span><br><span class="line"></span><br><span class="line">print(<span class="number">10</span>%<span class="number">3</span>)     <span class="comment"># 求余数</span></span><br><span class="line"></span><br><span class="line">print(<span class="number">3</span>**<span class="number">2</span>)     <span class="comment"># 乘方   </span></span><br></pre></td></tr></table></figure>


<h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><p>判断是真还是假，返回True/False</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">5</span>==<span class="number">6</span>)            <span class="comment"># ==， 相等</span></span><br><span class="line"></span><br><span class="line">print(<span class="number">8.0</span>!=<span class="number">8.0</span>)        <span class="comment"># !=, 不等</span></span><br><span class="line"></span><br><span class="line">print(<span class="number">3</span>&lt;<span class="number">3</span>, <span class="number">3</span>&lt;=<span class="number">3</span>)       <span class="comment"># &lt;, 小于; &lt;=, 小于等于</span></span><br><span class="line"></span><br><span class="line">print(<span class="number">4</span>&gt;<span class="number">5</span>, <span class="number">4</span>&gt;=<span class="number">0</span>)       <span class="comment"># &gt;, 大于; &gt;=, 大于等于</span></span><br><span class="line"></span><br><span class="line">print(<span class="number">5</span> <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>])    <span class="comment"># 5是list [1,3,5]的一个元素</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Attention</strong></p>
<p>这里对计算机小白来说有一道鸿沟需要跨越，编程语言中的<code>=</code>是赋值，表示把右边的值赋予左边的变量。而数学概念里的<code>=</code>在编程语言中用<code>==</code>表示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 1       # 把整数1赋值给变量a，此时a&#x3D;&#x3D;1</span><br><span class="line">a &#x3D; a + 1   # 把a+1也就是2赋值给变量a，此时a&#x3D;&#x3D;2</span><br></pre></td></tr></table></figure>

</blockquote>
<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>True/False之间的运算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">1</span>+<span class="number">1</span>==<span class="number">2</span> <span class="keyword">and</span> <span class="number">10</span>==<span class="number">2</span>*<span class="number">5</span>)       <span class="comment"># and, “与”运算，两者都为真才是真</span></span><br><span class="line"></span><br><span class="line">print(<span class="number">1</span>+<span class="number">1</span>!=<span class="number">2</span> <span class="keyword">or</span> <span class="number">3</span>&gt;=<span class="number">3</span>)           <span class="comment"># or, &quot;或&quot;运算， 其中之一为真即为真</span></span><br><span class="line"></span><br><span class="line">print(<span class="keyword">not</span> <span class="number">1</span>+<span class="number">1</span>==<span class="number">2</span>)               <span class="comment"># not, “非”运算， 取反</span></span><br></pre></td></tr></table></figure>
<p>需要说明一下，Python不同于其他编程语言的一点，在Python中是没有<code>&amp;&amp;</code>及<code>||</code>这两个运算符的，取而代之的是英文<code>and</code>和<code>or</code>。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 05 - Python 流程控制</title>
    <url>/2020/python05/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer" />



<p>在编程的世界中，流程控制决定了程序中语句执行的先后顺序，是程序员编程的基础，本节给大家介绍 Python 流程控制相关语法。</p>
<h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>if 语句用来进行条件判断。计算机之所以能做很多自动化任务，因为它可以自己做条件判断。</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;条件判断<span class="number">1</span>&gt;:</span><br><span class="line">    &lt;执行<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;条件判断<span class="number">2</span>&gt;:</span><br><span class="line">    &lt;执行<span class="number">2</span>&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;条件判断<span class="number">3</span>&gt;:</span><br><span class="line">    &lt;执行<span class="number">3</span>&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;执行<span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure>
<p>关键字 <code>&#39;elif&#39;</code> 是 <code>&#39;else if&#39;</code> 的缩写，上述结构中可以有0到多个 elif 部分，可以有0或1个else。</p>
<p>示例：BMI计算器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">height = <span class="built_in">input</span>(<span class="string">&quot;请输入你的身高（米）：&quot;</span>)</span><br><span class="line">weight = <span class="built_in">input</span>(<span class="string">&quot;请输入你的体重（千克）：&quot;</span>)</span><br><span class="line"></span><br><span class="line">bmi = <span class="built_in">float</span>(weight) / (<span class="built_in">float</span>(height) * <span class="built_in">float</span>(height))</span><br><span class="line">print(<span class="string">&quot;你的BMI指数：&quot;</span> + <span class="built_in">str</span>(bmi))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> bmi &lt; <span class="number">18.5</span>:</span><br><span class="line">    print(<span class="string">&quot;过轻&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">18.5</span> &lt;= bmi &lt; <span class="number">25</span>:</span><br><span class="line">    print(<span class="string">&quot;正常&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">25</span> &lt;= bmi &lt; <span class="number">28</span>:</span><br><span class="line">    print(<span class="string">&quot;过重&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">28</span> &lt;= bmi &lt; <span class="number">32</span>:</span><br><span class="line">    print(<span class="string">&quot;肥胖&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">32</span> &lt;= bmi:</span><br><span class="line">    print(<span class="string">&quot;严重肥胖&quot;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>试想，要计算1+2+3+…+10000，怎么样让计算机去完成这样的工作呢？</p>
<p>答案是，循环语句。</p>
<p>Python的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来，看例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure>
<p>执行这段代码，会依次打印<code>names</code>的每一个元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Michael</span><br><span class="line">Bob</span><br><span class="line">Tracy</span><br></pre></td></tr></table></figure>
<p>所以<code>for x in ...</code>循环就是把每个元素代入变量<code>x</code>，然后执行缩进块的语句。</p>
<p>回到计算1+2+3+…+10000的问题，以下代码即可实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10001</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span> + x</span><br><span class="line">print(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>
<p>Python3 <code>range() </code>函数返回的是一个可迭代对象（类型是对象），<code> list()</code> 函数可以把<code>range()</code>返回的可迭代对象转为一个列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">5</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>


<h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p>第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。其基本形式为：</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件：</span><br><span class="line">    执行语句……</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">9</span>):</span><br><span class="line">   print( <span class="string">&#x27;The count is:&#x27;</span>, count)</span><br><span class="line">   count = count + <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">print(<span class="string">&quot;Good bye!&quot;</span>)</span><br></pre></td></tr></table></figure>


<h3 id="break-用法"><a href="#break-用法" class="headerlink" title="break 用法"></a>break 用法</h3><p>break 语句可以跳出 for 和 while 循环。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">&#x27;Alexander Hamilton&#x27;</span>:     </span><br><span class="line">   <span class="keyword">if</span> letter == <span class="string">&#x27;i&#x27;</span>:        <span class="comment"># 字母为 i 时结束循环</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&#x27;当前字母 :&#x27;</span>, letter)</span><br></pre></td></tr></table></figure>


<h3 id="continue-用法"><a href="#continue-用法" class="headerlink" title="continue 用法"></a>continue 用法</h3><p>continue 语句被用来结束当前一轮循环，进行下一轮循环。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">&#x27;Alexander Hamilton&#x27;</span>:     </span><br><span class="line">   <span class="keyword">if</span> letter == <span class="string">&#x27;i&#x27;</span>:        <span class="comment"># 字母为 i 时直接进入下一轮循环</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&#x27;当前字母 :&#x27;</span>, letter)</span><br></pre></td></tr></table></figure>


<h3 id="pass-语句"><a href="#pass-语句" class="headerlink" title="pass 语句"></a>pass 语句</h3><p>Python pass 是空语句，是为了保持程序结构的完整性。它用于那些语法上必须要有什么语句，但程序什么也不做的场合。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这通常用于创建最小结构的类:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmptyClass</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>


<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本节给大家介绍了 Python 语法中的流程控制相关语法，方便后期在代码逻辑中进行条件控制。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 06 - Python 数据结构之 list 与 tuple</title>
    <url>/2020/python06/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer" />


<h2 id="list和tuple"><a href="#list和tuple" class="headerlink" title="list和tuple"></a>list和tuple</h2><p>sequence(序列)是一组有顺序的元素的集合。</p>
<p>序列有两种：tuple（元组） 和 list (列表)，tuple和list的主要区别在于，tuple的各个元素一旦建立便不可再变更，而list的各个元素可以随意变更。 </p>
<p>序列可以包含一个或多个元素，也可以没有任何元素。</p>
<h2 id="1-序列通用操作"><a href="#1-序列通用操作" class="headerlink" title="1. 序列通用操作"></a>1. 序列通用操作</h2><h3 id="1-1-index-索引"><a href="#1-1-index-索引" class="headerlink" title="1.1 index (索引)"></a>1.1 index (索引)</h3><p>序列中所有元素都有编号，这些编号是从 0 开始，依次递增，这个编号就是索引，索引用来访问序列中每一个位置的元素，索引是<strong>从<code>0</code>开始</strong>的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;Michael&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;Bob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;Tracy&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">3</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: <span class="built_in">list</span> index out of <span class="built_in">range</span></span><br></pre></td></tr></table></figure>
<p>当索引超出了范围时，Python会报一个<code>IndexError</code>错误，所以，要确保索引不要越界。</p>
<p>如果要取最后一个元素，除了计算索引位置外，还可以用<code>-1</code>做索引，直接获取最后一个元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates[-1]</span><br><span class="line">&#39;Tracy&#39;</span><br></pre></td></tr></table></figure>
<p>以此类推，可以获取倒数第2个、倒数第3个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates[-2]</span><br><span class="line">&#39;Bob&#39;</span><br><span class="line">&gt;&gt;&gt; classmates[-3]</span><br><span class="line">&#39;Michael&#39;</span><br><span class="line">&gt;&gt;&gt; classmates[-4]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure>
<p>当然，倒数第4个就越界了。</p>
<h3 id="1-2-分片"><a href="#1-2-分片" class="headerlink" title="1.2 分片"></a>1.2 分片</h3><p>分片是通过冒号操作来访问一定范围内的元素，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>num=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num[<span class="number">3</span>:<span class="number">10</span>]    // 表示从第<span class="number">4</span>（含）个到第<span class="number">10</span>（不含）个元素</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num[<span class="number">0</span>:<span class="number">3</span>]    // 取前<span class="number">3</span>个数据</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>由上所知，分片操作的的实现需要提供两个索引作为边界，是一个左闭右开的区间，也就是第 1 个索引包含在分片内，而第2个索引不包含在这个分片内。</p>
<h3 id="1-3-序列相加"><a href="#1-3-序列相加" class="headerlink" title="1.3 序列相加"></a>1.3 序列相加</h3><p>通过加号<code>+</code>可以将两个序列连接起来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;hello&#x27;</span>+<span class="string">&#x27; world !&#x27;</span></span><br><span class="line">  <span class="string">&#x27;hello world !&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]+[<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="string">&#x27;wangwu&#x27;</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;wangwu&#x27;</span>]</span><br></pre></td></tr></table></figure>


<h3 id="1-4-in-运算符"><a href="#1-4-in-运算符" class="headerlink" title="1.4 in 运算符"></a>1.4 in 运算符</h3><p><code>in</code>运算符用于检查一个元素是否在一个序列中，是则返回 true，否则返回 false，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span> = <span class="string">&#x27;believe&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;lie&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h3 id="1-5-序列长度、最大值和最小值"><a href="#1-5-序列长度、最大值和最小值" class="headerlink" title="1.5 序列长度、最大值和最小值"></a>1.5 序列长度、最大值和最小值</h3><p>内建函数 len、max、min 分别用于获取序列长度、最大值和最小值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>([<span class="number">11</span>,<span class="number">34</span>,<span class="number">23</span>])</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>([<span class="number">11</span>,<span class="number">34</span>,<span class="number">23</span>])</span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">min</span>([<span class="number">11</span>,<span class="number">34</span>,<span class="number">23</span>])</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>


<h2 id="2-list-列表"><a href="#2-list-列表" class="headerlink" title="2. list (列表)"></a>2. list (列表)</h2><p>列表是最常用的 Python 数据类型，它是一种有序的集合，可以随时添加和删除其中的元素。list用方括号<code>[ ]</code>表示。</p>
<p>比如，列出班里所有同学的名字，就可以用一个list表示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>变量<code>classmates</code>就是一个list。</p>
<p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">1</span>] = <span class="string">&#x27;Sarah&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Sarah&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br></pre></td></tr></table></figure>


<h3 id="2-1-常用的列表方法"><a href="#2-1-常用的列表方法" class="headerlink" title="2.1 常用的列表方法"></a>2.1 常用的列表方法</h3><p>列表提供了几个详细的方法，这些方法用于检查或者修改列表中的内容</p>
<h4 id="2-1-1-append"><a href="#2-1-1-append" class="headerlink" title="2.1.1 append"></a>2.1.1 append</h4><p>append 方法用于在列表的末尾追加新的元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.append(<span class="string">&#x27;Adam&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>, <span class="string">&#x27;Adam&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-count"><a href="#2-1-2-count" class="headerlink" title="2.1.2 count"></a>2.1.2 count</h4><p>count 方法用于统计某个元素在列表中出现的次数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; numList &#x3D; [1, 2, 3, 4, 5, 5, 5, 5, 6]</span><br><span class="line">&gt;&gt;&gt; num.count(5)    &#x2F;&#x2F; 统计numList列表中5出现的次数</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; name&#x3D;[&#39;a&#39;,&#39;a&#39;,&#39;abf&#39;,&#39;ark&#39;,&#39;nhk&#39;]</span><br><span class="line">&gt;&gt;&gt; name.count(&#39;a&#39;)     &#x2F;&#x2F; 统计name中字母a出现的次数</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h4 id="2-1-3-insert"><a href="#2-1-3-insert" class="headerlink" title="2.1.3 insert"></a>2.1.3 insert</h4><p>insert 方法用于把元素插入到指定的位置，比如索引为<code>1</code>的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates.insert(1, &#39;Jack&#39;)</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#39;Michael&#39;, &#39;Jack&#39;, &#39;Bob&#39;, &#39;Tracy&#39;, &#39;Adam&#39;]</span><br></pre></td></tr></table></figure>
<h4 id="2-1-4-pop"><a href="#2-1-4-pop" class="headerlink" title="2.1.4 pop"></a>2.1.4 pop</h4><p>要删除list末尾的元素，用<code>pop()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates.pop()</span><br><span class="line">&#39;Adam&#39;</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#39;Michael&#39;, &#39;Jack&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]</span><br></pre></td></tr></table></figure>
<p>要删除指定位置的元素，用<code>pop(i)</code>方法，其中<code>i</code>是索引位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates.pop(1)</span><br><span class="line">&#39;Jack&#39;</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]</span><br></pre></td></tr></table></figure>
<h4 id="2-1-5-reverse"><a href="#2-1-5-reverse" class="headerlink" title="2.1.5 reverse"></a>2.1.5 reverse</h4><p>reverse 方法是将列表中的元素进行反转操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; x &#x3D; [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; x.reverse()    &#x2F;&#x2F; 元素反向存储</span><br><span class="line">x</span><br><span class="line">[3, 2, 1]</span><br></pre></td></tr></table></figure>


<h2 id="3-tuple-元组"><a href="#3-tuple-元组" class="headerlink" title="3. tuple (元组)"></a>3. tuple (元组)</h2><p>tuple和list非常类似，但是tuple一旦初始化就不能修改，元组用<code>( )</code>表示。比如同样是列出同学的名字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates &#x3D; (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;)</span><br></pre></td></tr></table></figure>
<p>现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。你可以正常地使用<code>classmates[0]</code>，<code>classmates[-1]</code>，但不能赋值成另外的元素。</p>
<p>不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。写代码时，能用tuple就尽量用tuple。</p>
<h4 id="3-1-字符串是元组"><a href="#3-1-字符串是元组" class="headerlink" title="3.1 字符串是元组"></a>3.1 字符串是元组</h4><p>字符串是一种特殊的元组，因此可以执行元组的相关操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; str &#x3D; &#39;abcdef&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(str[2:4])</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 07 - Python 数据结构之 dict 与 set</title>
    <url>/2020/python07/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer" />


<h2 id="dict-字典-和-set-集合"><a href="#dict-字典-和-set-集合" class="headerlink" title="dict(字典) 和 set(集合)"></a>dict(字典) 和 set(集合)</h2><h3 id="dict-字典"><a href="#dict-字典" class="headerlink" title="dict 字典"></a>dict 字典</h3><p>dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。词典和list列表类似的地方，是包含有多个元素，每个元素以逗号分隔。但词典的元素包含有两部分，键和值，常见的是以字符串来表示键，值可以是任意对象。键和值两者一一对应。</p>
<p>举个例子，用dict实现一个<code>“名字”-“成绩”</code>的对照表，直接根据名字查找成绩：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;Michael&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;Bob&#x27;</span>: <span class="number">75</span>, <span class="string">&#x27;Tracy&#x27;</span>: <span class="number">85</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Michael&#x27;</span>]</span><br><span class="line"><span class="number">95</span></span><br></pre></td></tr></table></figure>

<p>把数据放入dict的方法，除了初始化时指定外，还可以后续通过key放入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Adam&#x27;</span>] = <span class="number">67</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Adam&#x27;</span>]</span><br><span class="line"><span class="number">67</span></span><br></pre></td></tr></table></figure>
<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值覆盖：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Jack&#x27;</span>] = <span class="number">90</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Jack&#x27;</span>]</span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Jack&#x27;</span>] = <span class="number">88</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Jack&#x27;</span>]</span><br><span class="line"><span class="number">88</span></span><br></pre></td></tr></table></figure>
<p>如果key不存在，dict就会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#39;Thomas&#39;]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">KeyError: &#39;Thomas&#39;</span><br></pre></td></tr></table></figure>
<p>要避免key不存在的错误，有两种办法，一是通过<code>in</code>判断key是否存在：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Thomas&#x27;</span> <span class="keyword">in</span> d</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>二是通过dict提供的<code>get()</code>方法，如果key不存在，可以返回<code>None</code>，或者自己指定的value：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">&#x27;Thomas&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">&#x27;Thomas&#x27;</span>, -<span class="number">1</span>)</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>注意：返回<code>None</code>的时候Python的交互环境不显示结果。</p>
<p>要删除一个key，用<code>pop(key)</code>方法，对应的value也会从dict中删除：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line"><span class="number">75</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">&#x27;Michael&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;Tracy&#x27;</span>: <span class="number">85</span>&#125;</span><br></pre></td></tr></table></figure>
<p>请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的，即dict是无序的。你不能通过下标引用元素，只能通过键来引用。</p>
<h4 id="dict元素的循环调用"><a href="#dict元素的循环调用" class="headerlink" title="dict元素的循环调用"></a>dict元素的循环调用</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;<span class="string">&#x27;lilei&#x27;</span>: <span class="number">90</span>, <span class="string">&#x27;lily&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;sam&#x27;</span>: <span class="number">57</span>, <span class="string">&#x27;tom&#x27;</span>: <span class="number">90</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dic:</span><br><span class="line">    <span class="built_in">print</span> dic[key]    <span class="comment"># 通过print的结果，我们可以再次确认，dic中的元素是没有顺序的。</span></span><br></pre></td></tr></table></figure>
<p>dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是<strong>不可变对象</strong>。</p>
<p>这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。</p>
<p>要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。</p>
<h4 id="dict的常用方法"><a href="#dict的常用方法" class="headerlink" title="dict的常用方法"></a>dict的常用方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic.keys()      # 返回dic所有的键</span><br><span class="line"></span><br><span class="line">dic.values()     # 返回dic所有的值</span><br><span class="line"></span><br><span class="line">print dic.items()     # 返回dic所有的元素（键值对）</span><br><span class="line"></span><br><span class="line">dic.clear()        # 清空dic，dict变为&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>另外有一个很常用的用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">del dic[&#39;tom&#39;]       # 删除 dic 的‘tom’元素</span><br></pre></td></tr></table></figure>
<p>del是Python中保留的关键字，用于删除对象。</p>
<p>与表类似，你可以用len()查询词典中的元素总数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(len(dic))</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h3><p>set和list类似，但不能有重复的元素。此外，set是无序的。set用<code>&#123; &#125;</code>表示。</p>
<p>要创建一个set，可以提供一个list作为输入集合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>注意，传入的参数<code>[1, 2, 3]</code>是一个list，而显示的<code>&#123;1, 2, 3&#125;</code>只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set内部存储的顺序。</p>
<p>重复元素在set中自动被过滤：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>add(key)</code>方法可以添加元素到set中，可以重复添加，但不会有效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>remove(key)</code>方法可以删除元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="built_in">set</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 &amp; s2</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 | s2</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>


<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>使用key-value存储结构的dict在Python中非常有用，选择不可变对象作为key很重要，最常用的key是字符串。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 08 - Python 函数</title>
    <url>/2020/python08/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer" />



<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>在Python中，定义一个函数要使用<code>def</code>语句，依次写出函数名、括号、括号中的参数和冒号<code>:</code>，然后，在缩进块中编写函数体，函数的返回值用<code>return</code>语句返回。</p>
<h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#定义一个函数</span><br><span class="line">def hello() :</span><br><span class="line">   print(&quot;Hello World!&quot;)</span><br><span class="line"></span><br><span class="line">#调用函数</span><br><span class="line">hello()</span><br></pre></td></tr></table></figure>


<h4 id="带参数和返回值的函数"><a href="#带参数和返回值的函数" class="headerlink" title="带参数和返回值的函数"></a>带参数和返回值的函数</h4><p>我们以自定义一个求绝对值的<code>my_abs</code>函数为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if x &gt;&#x3D; 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure>
<p>请自行测试并调用<code>my_abs</code>看看返回结果是否正确。</p>
<p>请注意，函数体内部的语句在执行时，一旦执行到<code>return</code>时，函数就执行完毕，并将结果返回。</p>
<p>return并不是必须的，当没有return, 或者return后面没有返回值时，函数将自动返回None。None是Python中的一个特别的数据类型，用来表示什么都没有，相当于C中的NULL。None多用于关键字参数传递的默认值。</p>
<h4 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h4><p>函数可以返回多个值吗？答案是肯定的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#定义多个返回值的函数</span><br><span class="line">def more(x, y):</span><br><span class="line">    nx &#x3D; x + 2</span><br><span class="line">    ny &#x3D; y - 2</span><br><span class="line">    return nx, ny</span><br><span class="line"></span><br><span class="line">#调用函数</span><br><span class="line">x, y &#x3D; more(10, 10)</span><br><span class="line">print(x, y)</span><br></pre></td></tr></table></figure>
<p>但其实这只是一种假象，Python函数返回的仍然是单一值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; r &#x3D; more(10, 10)</span><br><span class="line">&gt;&gt;&gt; print(r)</span><br><span class="line">(12, 8)</span><br></pre></td></tr></table></figure>
<p>原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>定义函数时，需要确定函数名和参数个数；</p>
<p>函数体内部可以用<code>return</code>随时返回函数结果；</p>
<p>函数执行完毕也没有<code>return</code>语句时，自动<code>return None</code>。</p>
<p>函数可以同时返回多个值，但其实就是一个tuple。</p>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>$$<br>请定义一个函数quadratic(a, b, c)，接收3个参数，返回一元二次方程 ax^2+bx+c=0的两个解。<br>提示：</p>
<p>一元二次方程的求根公式为：</p>
<p>x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}。<br>$$</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 09 - Python 模块</title>
    <url>/2020/python09/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer" />



<p>先给大家解释一下模块、包、库之间的概念：</p>
<p>在Python中，一个.py文件就构成一个模块module，用来封装一组功能；包package是将一类模块归集到一起，比模块的概念更大一些；库就是由其它程序员封装好的功能组，一般比包的概念更大一些。</p>
<h3 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h3><p>我们先写一个first.py文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def laugh():</span><br><span class="line">    print &#39;HaHaHaHa&#39;</span><br></pre></td></tr></table></figure>
<p>再写一个second.py，并引入first中的程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import first</span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    first.laugh()</span><br></pre></td></tr></table></figure>
<p>在second.py中，我们使用了first.py中定义的laugh()函数。</p>
<p>引入模块后，可以通过模块.对象的方式来调用引入模块中的某个对象。上面例子中，first为引入的模块，laugh()是我们所引入的对象。</p>
<p>Python中还有其它的引入方式,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import a as b            # 引入模块a，并将模块a重命名为b</span><br><span class="line"></span><br><span class="line">from a import function1  # 从模块a中引入function1对象。调用a中对象时，我们不用再说明模块，即直接使用function1，而不是a.function1。</span><br><span class="line"></span><br><span class="line">from a import *          # 从模块a中引入所有对象。调用a中对象时，我们不用再说明模块，即直接使用对象，而不是a.对象。</span><br></pre></td></tr></table></figure>
<p>这些引用方式，可以方便后面的程序书写。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过<code>_</code>前缀来实现的。</p>
<p>正常的函数和变量名是公开的（public），可以被直接引用，比如：<code>abc</code>，<code>x123</code>，<code>PI</code>等；</p>
<p>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的<code>__author__</code>，<code>__name__</code>就是特殊变量，<code>hello</code>模块定义的文档注释也可以用特殊变量<code>__doc__</code>访问，我们自己的变量一般不要用这种变量名；</p>
<p>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等；</p>
<p>之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p>
<p>private函数或变量不应该被别人引用，那它们有什么用呢？请看例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def _private_1(name):</span><br><span class="line">    return &#39;Hello, %s&#39; % name</span><br><span class="line"></span><br><span class="line">def _private_2(name):</span><br><span class="line">    return &#39;Hi, %s&#39; % name</span><br><span class="line"></span><br><span class="line">def greeting(name):</span><br><span class="line">    if len(name) &gt; 3:</span><br><span class="line">        return _private_1(name)</span><br><span class="line">    else:</span><br><span class="line">        return _private_2(name)</span><br></pre></td></tr></table></figure>
<p>我们在模块里公开<code>greeting()</code>函数，而把内部逻辑用private函数隐藏起来了，这样，调用<code>greeting()</code>函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即：</p>
<p>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</p>
<h3 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h3><p>在Python中，安装第三方模块，是通过包管理工具pip完成的。</p>
<p>注意：Mac或Linux上有可能并存Python 3.x和Python 2.x，因此对应的pip命令是<code>pip3</code>。</p>
<p>例如，我们要安装一个第三方库——Pillow，这是Python下非常强大的处理图像的工具库。安装Pillow的命令是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install Pillow</span><br></pre></td></tr></table></figure>
<p>macOS需要执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install Pillow</span><br></pre></td></tr></table></figure>
<p>耐心等待下载并安装后，就可以使用Pillow了。</p>
<h4 id="使用Anaconda"><a href="#使用Anaconda" class="headerlink" title="使用Anaconda"></a>使用Anaconda</h4><p>如果开发中需要用到很多第三方库，例如，上面提到的Pillow，以及MySQL驱动程序，Web框架Flask，科学计算Numpy等。用pip一个一个安装费时费力，还需要考虑兼容性。可以直接使用<a href="https://www.anaconda.com/">Anaconda</a>，这是一个基于Python的数据处理和科学计算平台，它已经内置了许多非常有用的第三方库，我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用，缺点是占用磁盘空间大。</p>
<p>可以从<a href="https://www.anaconda.com/download/">Anaconda官网</a>下载GUI安装包，安装包有500~600M，所以需要耐心等待下载。下载后直接安装，Anaconda会把系统Path中的python指向自己自带的Python，并且，Anaconda安装的第三方模块会安装在Anaconda自己的路径下，不影响系统已安装的Python目录。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 10 - Python 面向对象：基础知识</title>
    <url>/2020/python10/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer" />



<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h4><p>面向对象编程——Object Oriented Programming，简称OOP，是一种<strong>程序设计思想</strong>。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p>
<p>面向对象的编程思想是基于面向过程的思想发展而来的。</p>
<p>面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。面向过程通常会把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。而面向对象的程序设计把计算机程序视为一组对象的集合，每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p>
<p>在单体程序逻辑比较简单的时候，用面向过程的方法设计会更简单，但当系统趋于复杂时，面向过程的设计就会捉襟见肘了，此时利用面向对象的设计思想会更清晰明了，容易维护。</p>
<h4 id="一切皆对象"><a href="#一切皆对象" class="headerlink" title="一切皆对象"></a>一切皆对象</h4><p>在Python中，所有数据类型都可以视为对象。</p>
<p>我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。</p>
<p>假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个dict表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std1 &#x3D; &#123; &#39;name&#39;: &#39;Michael&#39;, &#39;score&#39;: 98 &#125;</span><br><span class="line">std2 &#x3D; &#123; &#39;name&#39;: &#39;Bob&#39;, &#39;score&#39;: 81 &#125;</span><br></pre></td></tr></table></figure>
<p>而处理学生成绩可以通过函数实现，比如打印学生的成绩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def print_score(std):</span><br><span class="line">    print(&#39;%s: %s&#39; % (std[&#39;name&#39;], std[&#39;score&#39;]))</span><br></pre></td></tr></table></figure>
<p>如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是<code>Student</code>这种数据类型应该被视为一个对象，这个对象拥有<code>name</code>和<code>score</code>这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个<code>print_score</code>消息，让对象自己把自己的数据打印出来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.score &#x3D; score</span><br><span class="line"></span><br><span class="line">    def print_score(self):    # 类中定义的方法第一个参数必须是self，无论是否用到</span><br><span class="line">        print(&#39;%s: %s&#39; % (self.name, self.score))</span><br></pre></td></tr></table></figure>
<p>给对象发消息实际上就是调用对象的函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bart &#x3D; Student(&#39;Bart Simpson&#39;, 59)</span><br><span class="line">lisa &#x3D; Student(&#39;Lisa Simpson&#39;, 87)</span><br><span class="line">bart.print_score()</span><br><span class="line">lisa.print_score()</span><br></pre></td></tr></table></figure>
<p>面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。Class是一种抽象概念，比如我们定义的Class——Student，是指学生这个概念，而实例（Instance）则是一个个具体的Student，比如，Bart Simpson和Lisa Simpson是两个具体的Student。</p>
<p>所以，面向对象的设计思想是<strong>抽象出Class，根据Class创建Instance</strong>。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>数据封装、继承和多态(Encapsulation, Inheritance, Polymorphism)是面向对象的三大特点，我们后面会详细讲解。</p>
<p>将各种各样的东西分类，从而了解世界，从人类祖先开始，我们就在练习了这个认知过程，面向对象是符合人类思维习惯的。</p>
<p>所谓面向过程，也就是执行完一个语句再执行下一个，更多的是机器思维。通过面向对象的编程，我们可以更方便的表达思维中的复杂想法。当然，面向对象和面向过程并不是完全独立的，在面向对象的程序内部，比如一个方法的实现，依然是面向过程的。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 12 - Python 面向对象：继承和多态</title>
    <url>/2020/python12/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer" />




<h3 id="继承（Inheritance）"><a href="#继承（Inheritance）" class="headerlink" title="继承（Inheritance）"></a>继承（Inheritance）</h3><p>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为父类（Super class）。</p>
<p>比如，我们已经编写了一个名为<code>Animal</code>的class，有一个<code>run()</code>方法可以直接打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#39;Animal is running...&#39;)</span><br></pre></td></tr></table></figure>
<p>当我们需要编写<code>Dog</code>和<code>Cat</code>类时，就可以直接从<code>Animal</code>类继承：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Dog(Animal):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class Cat(Animal):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>对于<code>Dog</code>来说，<code>Animal</code>就是它的父类，对于<code>Animal</code>来说，<code>Dog</code>就是它的子类。<code>Cat</code>和<code>Dog</code>类似。</p>
<p>继承有什么好处？最大的好处是子类获得了父类的全部功能。由于<code>Animial</code>实现了<code>run()</code>方法，因此，<code>Dog</code>和<code>Cat</code>作为它的子类，什么事也没干，就自动拥有了<code>run()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dog &#x3D; Dog()</span><br><span class="line">dog.run()</span><br><span class="line"></span><br><span class="line">cat &#x3D; Cat()</span><br><span class="line">cat.run()</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Animal is running...</span><br><span class="line">Animal is running...</span><br></pre></td></tr></table></figure>
<p>当然，也可以对子类增加一些方法，比如Dog类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Dog(Animal):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#39;Dog is running...&#39;)</span><br><span class="line"></span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&#39;Eating meat...&#39;)</span><br></pre></td></tr></table></figure>


<p>继承的第二个好处需要我们对代码做一点改进。你看到了，无论是<code>Dog</code>还是<code>Cat</code>，它们<code>run()</code>的时候，显示的都是<code>Animal is running...</code>，符合逻辑的做法是分别显示<code>Dog is running...</code>和<code>Cat is running...</code>，因此，对<code>Dog</code>和<code>Cat</code>类改进如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Dog(Animal):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#39;Dog is running...&#39;)</span><br><span class="line"></span><br><span class="line">class Cat(Animal):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#39;Cat is running...&#39;)</span><br></pre></td></tr></table></figure>
<p>再次运行，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dog is running...</span><br><span class="line">Cat is running...</span><br></pre></td></tr></table></figure>


<p>当子类和父类都存在相同的<code>run()</code>方法时，我们说，子类的<code>run()</code>覆盖（override）了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。这样，我们就获得了继承的另一个好处：<strong>多态</strong>。</p>
<h3 id="多态（Polymorphism）"><a href="#多态（Polymorphism）" class="headerlink" title="多态（Polymorphism）"></a>多态（Polymorphism）</h3><p>要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; list() # a是list类型</span><br><span class="line">b &#x3D; Animal() # b是Animal类型</span><br><span class="line">c &#x3D; Dog() # c是Dog类型</span><br></pre></td></tr></table></figure>
<p>判断一个变量是否是某个类型可以用<code>isinstance()</code>判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(a, list)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(b, Animal)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(c, Dog)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>看来<code>a</code>、<code>b</code>、<code>c</code>确实对应着<code>list</code>、<code>Animal</code>、<code>Dog</code>这3种类型。</p>
<p>但是等等，试试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(c, Animal)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>看来<code>c</code>不仅仅是<code>Dog</code>，<code>c</code>还是<code>Animal</code>！</p>
<p>不过仔细想想，这是有道理的，因为<code>Dog</code>是从<code>Animal</code>继承下来的，当我们创建了一个<code>Dog</code>的实例<code>c</code>时，我们认为<code>c</code>的数据类型是<code>Dog</code>没错，但<code>c</code>同时也是<code>Animal</code>也没错。</p>
<p>所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b &#x3D; Animal()</span><br><span class="line">&gt;&gt;&gt; isinstance(b, Dog)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p><code>Dog</code>可以看成<code>Animal</code>，但<code>Animal</code>不可以看成<code>Dog</code>。</p>
<p>要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个<code>Animal</code>类型的变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def run_twice(animal):</span><br><span class="line">    animal.run()</span><br><span class="line">    animal.run()</span><br></pre></td></tr></table></figure>
<p>当我们传入<code>Animal</code>的实例时，<code>run_twice()</code>就打印出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; run_twice(Animal())</span><br><span class="line">Animal is running...</span><br><span class="line">Animal is running...</span><br></pre></td></tr></table></figure>
<p>当我们传入<code>Dog</code>的实例时，<code>run_twice()</code>就打印出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; run_twice(Dog())</span><br><span class="line">Dog is running...</span><br><span class="line">Dog is running...</span><br></pre></td></tr></table></figure>
<p>当我们传入<code>Cat</code>的实例时，<code>run_twice()</code>就打印出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; run_twice(Cat())</span><br><span class="line">Cat is running...</span><br><span class="line">Cat is running...</span><br></pre></td></tr></table></figure>
<p>看上去没啥意思，但是仔细想想，现在，如果我们再定义一个<code>Tortoise</code>类型，也从<code>Animal</code>派生：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Tortoise(Animal):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#39;Tortoise is running slowly...&#39;)</span><br></pre></td></tr></table></figure>
<p>当我们调用<code>run_twice()</code>时，传入<code>Tortoise</code>的实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; run_twice(Tortoise())</span><br><span class="line">Tortoise is running slowly...</span><br><span class="line">Tortoise is running slowly...</span><br></pre></td></tr></table></figure>
<p>你会发现，新增一个<code>Animal</code>的子类，不必对<code>run_twice()</code>做任何修改，实际上，任何依赖<code>Animal</code>作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。</p>
<p>多态的好处就是，当我们需要传入<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>……时，我们只需要接收<code>Animal</code>类型就可以了，因为<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>……都是<code>Animal</code>类型，然后，按照<code>Animal</code>类型进行操作即可。由于<code>Animal</code>类型有<code>run()</code>方法，因此，传入的任意类型，只要是<code>Animal</code>类或者子类，就会自动调用实际类型的<code>run()</code>方法，这就是多态的意思：</p>
<p>对于一个变量，我们只需要知道它是<code>Animal</code>类型，无需确切地知道它的子类型，就可以放心地调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Animal</code>、<code>Dog</code>、<code>Cat</code>还是<code>Tortoise</code>对象上，由<strong>运行时该对象的确切类型决定</strong>，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p>
<p>对扩展开放：允许新增<code>Animal</code>子类；</p>
<p>对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。</p>
<p>继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到<strong>根类object</strong>，这些继承关系看上去就像一颗树。比如如下的继承树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                ┌───────────────┐</span><br><span class="line">                │    object     │</span><br><span class="line">                └───────────────┘</span><br><span class="line">                        │</span><br><span class="line">           ┌────────────┴────────────┐</span><br><span class="line">           │                         │</span><br><span class="line">           ▼                         ▼</span><br><span class="line">    ┌─────────────┐           ┌─────────────┐</span><br><span class="line">    │   Animal    │           │    Plant    │</span><br><span class="line">    └─────────────┘           └─────────────┘</span><br><span class="line">           │                         │</span><br><span class="line">     ┌─────┴──────┐            ┌─────┴──────┐</span><br><span class="line">     │            │            │            │</span><br><span class="line">     ▼            ▼            ▼            ▼</span><br><span class="line">┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐</span><br><span class="line">│   Dog   │  │   Cat   │  │  Tree   │  │ Flower  │</span><br><span class="line">└─────────┘  └─────────┘  └─────────┘  └─────────┘</span><br></pre></td></tr></table></figure>


<h4 id="静态语言-vs-动态语言"><a href="#静态语言-vs-动态语言" class="headerlink" title="静态语言 vs 动态语言"></a>静态语言 vs 动态语言</h4><p>对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。</p>
<p>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Timer(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#39;Start...&#39;)</span><br></pre></td></tr></table></figure>
<p><strong>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</strong></p>
<p>Python的“file-like object”就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为“file-like object”。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>继承可以把父类的所有功能都直接拿过来，这样就不必从零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖。</p>
<p>动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 11 - Python 面向对象：类和实例</title>
    <url>/2020/python11/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer" />



<p>面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，而实例是根据类创建出来的一个个具体的对象。</p>
<h3 id="定义一个类"><a href="#定义一个类" class="headerlink" title="定义一个类"></a>定义一个类</h3><p>仍以Student类为例，在Python中，定义类是通过<code>class</code>关键字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p><code>class</code>后面紧接着是类名，即<code>Student</code>，类名以大写字母开头，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用<code>object</code>类，这是所有类最终都会继承的类。</p>
<p>定义好了<code>Student</code>类，就可以根据<code>Student</code>类创建出<code>Student</code>的实例，创建实例是通过类名+()实现的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bart &#x3D; Student()</span><br><span class="line">&gt;&gt;&gt; bart</span><br><span class="line">&lt;__main__.Student object at 0x10a67a590&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; Student</span><br><span class="line">&lt;class &#39;__main__.Student&#39;&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到，变量<code>bart</code>指向的就是一个<code>Student</code>的实例，后面的<code>0x10a67a590</code>是内存地址，每个object的地址都不一样，而<code>Student</code>本身则是一个类。</p>
<p>可以自由地给一个实例变量绑定属性，比如，给实例<code>bart</code>绑定一个<code>name</code>属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bart.name &#x3D; &#39;Bart Simpson&#39;</span><br><span class="line">&gt;&gt;&gt; bart.name</span><br><span class="line">&#39;Bart Simpson&#39;</span><br></pre></td></tr></table></figure>


<h3 id="init方法"><a href="#init方法" class="headerlink" title="init方法"></a>init方法</h3><p>由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的<code>__init__</code>方法，在创建实例的时候，就把<code>name</code>，<code>score</code>等属性绑上去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.score &#x3D; score</span><br></pre></td></tr></table></figure>
<p> 注意：特殊方法“__init__”前后分别有两个下划线！！！</p>
<p><code>__init__</code>方法的<strong>第一个参数永远是<code>self</code>，表示创建的实例本身</strong>，因此，在<code>__init__</code>方法内部，就可以把各种属性绑定到<code>self</code>，因为<code>self</code>就指向创建的实例本身。</p>
<p>有了<code>__init__</code>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<code>__init__</code>方法匹配的参数，但<code>self</code>不需要传，Python解释器自己会把实例变量传进去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bart &#x3D; Student(&#39;Bart Simpson&#39;, 59)</span><br><span class="line">&gt;&gt;&gt; bart.name</span><br><span class="line">&#39;Bart Simpson&#39;</span><br><span class="line">&gt;&gt;&gt; bart.score</span><br><span class="line">59</span><br></pre></td></tr></table></figure>
<p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量<code>self</code>。</p>
<h3 id="数据封装（Encapsulation）"><a href="#数据封装（Encapsulation）" class="headerlink" title="数据封装（Encapsulation）"></a>数据封装（Encapsulation）</h3><p>面向对象编程的一个重要特点就是数据封装（Encapsulation）。在上面的<code>Student</code>类中，每个实例就拥有各自的<code>name</code>和<code>score</code>这些数据。我们可以通过函数来访问这些数据，比如打印一个学生的成绩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def print_score(std):</span><br><span class="line">...     print(&#39;%s: %s&#39; % (std.name, std.score))</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; print_score(bart)</span><br><span class="line">Bart Simpson: 59</span><br></pre></td></tr></table></figure>
<p>但是，既然<code>Student</code>实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在<code>Student</code>类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和<code>Student</code>类本身是关联起来的，我们称之为类的方法（method）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.score &#x3D; score</span><br><span class="line"></span><br><span class="line">    def print_score(self):</span><br><span class="line">        print(&#39;%s: %s&#39; % (self.name, self.score))</span><br></pre></td></tr></table></figure>
<p>要定义一个方法，除了第一个参数是<code>self</code>外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了<code>self</code>不用传递，其他参数正常传入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bart.print_score()</span><br><span class="line">Bart Simpson: 59</span><br></pre></td></tr></table></figure>
<p>由此可以看出，类其实就是将数据和功能组合起来的一种结构。我们从外部看<code>Student</code>类，就只需要知道，创建实例时给出<code>name</code>和<code>score</code>，而如何打印，都是在<code>Student</code>类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，不用知道内部实现的细节。</p>
<p>我们可以继续给<code>Student</code>类增加新的方法，比如<code>get_grade</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def get_grade(self):</span><br><span class="line">        if self.score &gt;&#x3D; 90:</span><br><span class="line">            return &#39;A&#39;</span><br><span class="line">        elif self.score &gt;&#x3D; 60:</span><br><span class="line">            return &#39;B&#39;</span><br><span class="line">        else:</span><br><span class="line">            return &#39;C&#39;</span><br></pre></td></tr></table></figure>
<p>同样的，<code>get_grade</code>方法可以直接在实例变量上调用，不需要知道内部实现细节：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lisa &#x3D; Student(&#39;Lisa&#39;, 99) </span><br><span class="line">bart &#x3D; Student(&#39;Bart&#39;, 59) </span><br><span class="line">print(lisa.name, lisa.get_grade()) </span><br><span class="line">print(bart.name, bart.get_grade())</span><br></pre></td></tr></table></figure>


<p>需要<strong>注意</strong>的是，和Java、C++等静态语言不同，Python允许对实例变量动态绑定任何数据，也就是说，同一个类的两个实例可能拥有的不同名称的属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bart &#x3D; Student(&#39;Bart Simpson&#39;, 59)</span><br><span class="line">&gt;&gt;&gt; lisa &#x3D; Student(&#39;Lisa Simpson&#39;, 87)</span><br><span class="line">&gt;&gt;&gt; bart.age &#x3D; 8</span><br><span class="line">&gt;&gt;&gt; bart.age</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; lisa.age</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &#39;Student&#39; object has no attribute &#39;age&#39;</span><br></pre></td></tr></table></figure>


<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；</p>
<p>通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 13 - Python 面向对象：访问限制</title>
    <url>/2020/python13/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer" />


<p>在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。</p>
<p>但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的<code>name</code>、<code>score</code>属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bart &#x3D; Student(&#39;Bart Simpson&#39;, 59)</span><br><span class="line">&gt;&gt;&gt; bart.score</span><br><span class="line">59</span><br><span class="line">&gt;&gt;&gt; bart.score &#x3D; 99</span><br><span class="line">&gt;&gt;&gt; bart.score</span><br><span class="line">99</span><br></pre></td></tr></table></figure>

<h3 id="实例的私有变量（private）"><a href="#实例的私有变量（private）" class="headerlink" title="实例的私有变量（private）"></a>实例的私有变量（private）</h3><p>在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。</p>
<p>所以，我们把Student类改一改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.__name &#x3D; name</span><br><span class="line">        self.__score &#x3D; score</span><br><span class="line"></span><br><span class="line">    def print_score(self):</span><br><span class="line">        print(&#39;%s: %s&#39; % (self.__name, self.__score))</span><br></pre></td></tr></table></figure>
<p>改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问<code>实例变量.__name</code>和<code>实例变量.__score</code>了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bart &#x3D; Student(&#39;Bart Simpson&#39;, 59)</span><br><span class="line">&gt;&gt;&gt; bart.__name</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &#39;Student&#39; object has no attribute &#39;__name&#39;</span><br></pre></td></tr></table></figure>
<p>这样就确保了外部代码不能随意修改对象内部的状态，代码更加健壮。</p>
<p>但是如果外部代码要获取name和score怎么办？可以给Student类增加<code>get_name</code>和<code>get_score</code>这样的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def get_name(self):</span><br><span class="line">        return self.__name</span><br><span class="line"></span><br><span class="line">    def get_score(self):</span><br><span class="line">        return self.__score</span><br></pre></td></tr></table></figure>
<p>如果又要允许外部代码修改score怎么办？可以再给Student类增加<code>set_score</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def set_score(self, score):</span><br><span class="line">        self.__score &#x3D; score</span><br></pre></td></tr></table></figure>
<p>你也许会问，原先那种直接通过<code>bart.score = 99</code>也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def set_score(self, score):</span><br><span class="line">        if 0 &lt;&#x3D; score &lt;&#x3D; 100:</span><br><span class="line">            self.__score &#x3D; score</span><br><span class="line">        else:</span><br><span class="line">            raise ValueError(&#39;bad score&#39;)</span><br></pre></td></tr></table></figure>


<p>需要注意的是，在Python中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。</p>
<p>有些时候，你会看到以一个下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p>
<p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bart._Student__name</span><br><span class="line">&#39;Bart Simpson&#39;</span><br></pre></td></tr></table></figure>
<p>但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把<code>__name</code>改成不同的变量名。</p>
<p>总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。</p>
<p>最后注意下面的这种<em>错误写法</em>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bart &#x3D; Student(&#39;Bart Simpson&#39;, 59)</span><br><span class="line">&gt;&gt;&gt; bart.get_name()</span><br><span class="line">&#39;Bart Simpson&#39;</span><br><span class="line">&gt;&gt;&gt; bart.__name &#x3D; &#39;New Name&#39; # 设置__name变量！</span><br><span class="line">&gt;&gt;&gt; bart.__name</span><br><span class="line">&#39;New Name&#39;</span><br></pre></td></tr></table></figure>
<p>表面上看，外部代码“成功”地设置了<code>__name</code>变量，但实际上这个<code>__name</code>变量和class内部的<code>__name</code>变量<em>不是</em>一个变量！内部的<code>__name</code>变量已经被Python解释器自动改成了<code>_Student__name</code>，而外部代码给<code>bart</code>新增了一个<code>__name</code>变量。不信试试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bart.get_name() # get_name()内部返回self.__name</span><br><span class="line">&#39;Bart Simpson&#39;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 14 - Python 面向对象：实例属性和类属性</title>
    <url>/2020/python14/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer" />



<p>由于Python是动态语言，类的实例可以任意绑定属性。</p>
<p>给实例绑定属性的方法是通过实例变量，或者通过<code>self</code>变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line"></span><br><span class="line">s &#x3D; Student(&#39;Bob&#39;)</span><br><span class="line">s.score &#x3D; 90</span><br></pre></td></tr></table></figure>
<p>但是，如果<code>Student</code>类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归<code>Student</code>类所有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    name &#x3D; &#39;Student&#39;</span><br></pre></td></tr></table></figure>
<p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">...     name &#x3D; &#39;Student&#39;</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; s &#x3D; Student() # 创建实例s</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; print(Student.name) # 打印类的name属性</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; s.name &#x3D; &#39;Michael&#39; # 给实例绑定name属性</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span><br><span class="line">Michael</span><br><span class="line">&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; del s.name # 如果删除实例的name属性</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span><br><span class="line">Student</span><br></pre></td></tr></table></figure>
<p>从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>实例属性属于各个实例所有，互不干扰；</p>
<p>类属性属于类所有，所有实例共享一个属性；</p>
<p>不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 15 - Python 面向对象：内置函数</title>
    <url>/2020/python15/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer" />




<p>当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？</p>
<h3 id="使用type"><a href="#使用type" class="headerlink" title="使用type()"></a>使用type()</h3><p><code>type()</code>函数返回对象的Class类型。</p>
<p>基本类型都可以用<code>type()</code>判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; type(123)</span><br><span class="line">&lt;class &#39;int&#39;&gt;</span><br><span class="line">&gt;&gt;&gt; type(&#39;str&#39;)</span><br><span class="line">&lt;class &#39;str&#39;&gt;</span><br><span class="line">&gt;&gt;&gt; type(None)</span><br><span class="line">&lt;type(None) &#39;NoneType&#39;&gt;</span><br></pre></td></tr></table></figure>
<p>如果一个变量指向函数或者类，也可以用<code>type()</code>判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; type(abs)</span><br><span class="line">&lt;class &#39;builtin_function_or_method&#39;&gt;</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;class &#39;__main__.Animal&#39;&gt;</span><br></pre></td></tr></table></figure>
<p>如果我们要在<code>if</code>语句中判断，就需要比较两个变量的type类型是否相同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; type(123)&#x3D;&#x3D;type(456)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(123)&#x3D;&#x3D;int</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(&#39;abc&#39;)&#x3D;&#x3D;type(&#39;123&#39;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(&#39;abc&#39;)&#x3D;&#x3D;str</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(&#39;abc&#39;)&#x3D;&#x3D;type(123)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>判断基本数据类型可以直接写<code>int</code>，<code>str</code>等，但如果要判断一个对象是否是函数怎么办？可以使用<code>types</code>模块中定义的常量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import types</span><br><span class="line">&gt;&gt;&gt; def fn():</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; type(fn)&#x3D;&#x3D;types.FunctionType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(abs)&#x3D;&#x3D;types.BuiltinFunctionType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(lambda x: x)&#x3D;&#x3D;types.LambdaType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type((x for x in range(10)))&#x3D;&#x3D;types.GeneratorType</span><br><span class="line">True</span><br></pre></td></tr></table></figure>


<h3 id="使用isinstance"><a href="#使用isinstance" class="headerlink" title="使用isinstance()"></a>使用isinstance()</h3><p>我们要判断对象所属的class的类型，可以使用<code>isinstance()</code>函数。</p>
<p>我们回顾上次的例子，如果继承关系是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">object -&gt; Animal -&gt; Dog -&gt; Husky</span><br></pre></td></tr></table></figure>
<p>那么，<code>isinstance()</code>就可以告诉我们，一个对象是否是某种类型。先创建3种类型的对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; Animal()</span><br><span class="line">&gt;&gt;&gt; d &#x3D; Dog()</span><br><span class="line">&gt;&gt;&gt; h &#x3D; Husky()</span><br></pre></td></tr></table></figure>
<p>然后，判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(h, Husky)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>没有问题，因为<code>h</code>变量指向的就是Husky对象。</p>
<p>再判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(h, Dog)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p><code>h</code>虽然自身是Husky类型，但由于Husky是从Dog继承下来的，所以，<code>h</code>也还是Dog类型。换句话说，<code>isinstance()</code>判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。</p>
<p>因此，我们可以确信，<code>h</code>还是Animal类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(h, Animal)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>同理，实际类型是Dog的<code>d</code>也是Animal类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(d, Dog) and isinstance(d, Animal)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>但是，<code>d</code>不是Husky类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(d, Husky)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>能用<code>type()</code>判断的基本类型也可以用<code>isinstance()</code>判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(&#39;a&#39;, str)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(123, int)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(b&#39;a&#39;, bytes)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>并且还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p> 总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。</p>
<h3 id="使用dir"><a href="#使用dir" class="headerlink" title="使用dir()"></a>使用dir()</h3><p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dir(&#39;ABC&#39;)</span><br><span class="line">[&#39;__add__&#39;, &#39;__class__&#39;,..., &#39;__subclasshook__&#39;, &#39;capitalize&#39;, &#39;casefold&#39;,..., &#39;zfill&#39;]</span><br></pre></td></tr></table></figure>
<p>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法，所以，下面的代码是等价的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; len(&#39;ABC&#39;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; &#39;ABC&#39;.__len__()</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>我们自己写的类，如果也想用<code>len(myObj)</code>的话，就自己写一个<code>__len__()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class MyDog(object):</span><br><span class="line">...     def __len__(self):</span><br><span class="line">...         return 100</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; dog &#x3D; MyDog()</span><br><span class="line">&gt;&gt;&gt; len(dog)</span><br><span class="line">100</span><br></pre></td></tr></table></figure>
<p>剩下的都是普通属性或方法，比如<code>lower()</code>返回小写的字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;ABC&#39;.lower()</span><br><span class="line">&#39;abc&#39;</span><br></pre></td></tr></table></figure>


<h3 id="使用getattr-、setattr-以及hasattr"><a href="#使用getattr-、setattr-以及hasattr" class="headerlink" title="使用getattr()、setattr()以及hasattr()"></a>使用getattr()、setattr()以及hasattr()</h3><p>仅仅把属性和方法列出来是不够的，配合<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class MyObject(object):</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         self.x &#x3D; 9</span><br><span class="line">...     def power(self):</span><br><span class="line">...         return self.x * self.x</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; obj &#x3D; MyObject()</span><br></pre></td></tr></table></figure>
<p>紧接着，可以测试该对象的属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; hasattr(obj, &#39;x&#39;) # 有属性&#39;x&#39;吗？</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; obj.x</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; hasattr(obj, &#39;y&#39;) # 有属性&#39;y&#39;吗？</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; setattr(obj, &#39;y&#39;, 19) # 设置一个属性&#39;y&#39;</span><br><span class="line">&gt;&gt;&gt; hasattr(obj, &#39;y&#39;) # 有属性&#39;y&#39;吗？</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; getattr(obj, &#39;y&#39;) # 获取属性&#39;y&#39;</span><br><span class="line">19</span><br><span class="line">&gt;&gt;&gt; obj.y # 获取属性&#39;y&#39;</span><br><span class="line">19</span><br></pre></td></tr></table></figure>
<p>如果试图获取不存在的属性，会抛出AttributeError的错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; getattr(obj, &#39;z&#39;) # 获取属性&#39;z&#39;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &#39;MyObject&#39; object has no attribute &#39;z&#39;</span><br></pre></td></tr></table></figure>
<p>可以传入一个default参数，如果属性不存在，就返回默认值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; getattr(obj, &#39;z&#39;, 404) # 获取属性&#39;z&#39;，如果不存在，返回默认值404</span><br><span class="line">404</span><br></pre></td></tr></table></figure>
<p>也可以获得对象的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; hasattr(obj, &#39;power&#39;) # 有属性&#39;power&#39;吗？</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; getattr(obj, &#39;power&#39;) # 获取属性&#39;power&#39;</span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; fn &#x3D; getattr(obj, &#39;power&#39;) # 获取属性&#39;power&#39;并赋值到变量fn</span><br><span class="line">&gt;&gt;&gt; fn # fn指向obj.power</span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的</span><br><span class="line">81</span><br></pre></td></tr></table></figure>


<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过Python内置的一系列函数，我们可以对任意一个Python对象进行剖析，拿到其内部的数据。要注意的是，只有在不知道对象信息的时候，我们才会去获取对象信息。如果可以直接写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum &#x3D; obj.x + obj.y</span><br></pre></td></tr></table></figure>
<p>就不要写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum &#x3D; getattr(obj, &#39;x&#39;) + getattr(obj, &#39;y&#39;)</span><br></pre></td></tr></table></figure>
<p>一个正确的用法的例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def readImage(fp):</span><br><span class="line">    if hasattr(fp, &#39;read&#39;):</span><br><span class="line">        return readData(fp)</span><br><span class="line">    return None</span><br></pre></td></tr></table></figure>
<p>假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取。<code>hasattr()</code>就派上了用场。</p>
<p>请注意，在Python这类动态语言中，根据鸭子类型，有<code>read()</code>方法，不代表该fp对象就是一个文件流，它也可能是网络流，也可能是内存中的一个字节流，但只要<code>read()</code>方法返回的是有效的图像数据，就不影响读取图像的功能。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 16 - Python 常用模块：os模块与shutil模块</title>
    <url>/2020/python16/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer" />



<h3 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h3><p>Python内置的<code>os</code>模块可以直接调用操作系统提供的接口。</p>
<p>打开Python交互式命令行，我们来看看如何使用<code>os</code>模块的基本功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; os.name # 操作系统类型</span><br><span class="line">&#39;posix&#39;</span><br></pre></td></tr></table></figure>
<p>如果是<code>posix</code>，说明系统是<code>Linux</code>、<code>Unix</code>或<code>Mac OS X</code>，如果是<code>nt</code>，就是<code>Windows</code>系统。</p>
<p>要获取详细的系统信息，可以调用<code>uname()</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.uname()</span><br><span class="line">posix.uname_result(sysname&#x3D;&#39;Darwin&#39;, nodename&#x3D;&#39;MichaelMacPro.local&#39;, release&#x3D;&#39;14.3.0&#39;, version&#x3D;&#39;Darwin Kernel Version 14.3.0: Mon Mar 23 11:59:05 PDT 2015; root:xnu-2782.20.48~5&#x2F;RELEASE_X86_64&#39;, machine&#x3D;&#39;x86_64&#39;)</span><br></pre></td></tr></table></figure>
<p>注意<code>uname()</code>函数在Windows上不提供，也就是说，<code>os</code>模块的某些函数是跟操作系统相关的。</p>
<p>在操作系统中定义的环境变量，全部保存在<code>os.environ</code>这个变量中，可以直接查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.environ</span><br><span class="line">environ(&#123;&#39;VERSIONER_PYTHON_PREFER_32_BIT&#39;: &#39;no&#39;, &#39;TERM_PROGRAM_VERSION&#39;: &#39;326&#39;, &#39;LOGNAME&#39;: &#39;michael&#39;, &#39;USER&#39;: &#39;michael&#39;, &#39;PATH&#39;: &#39;&#x2F;usr&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;opt&#x2F;X11&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#39;, ...&#125;)</span><br></pre></td></tr></table></figure>


<h4 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h4><p>操作文件和目录的函数一部分放在<code>os</code>模块中，一部分放在<code>os.path</code>模块中，这一点要注意一下。查看、创建和删除目录可以这么调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看当前目录的绝对路径:</span><br><span class="line">&gt;&gt;&gt; os.path.abspath(&#39;.&#39;)</span><br><span class="line">&#39;&#x2F;Users&#x2F;michael&#39;</span><br><span class="line"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span><br><span class="line">&gt;&gt;&gt; os.path.join(&#39;&#x2F;Users&#x2F;michael&#39;, &#39;testdir&#39;)</span><br><span class="line">&#39;&#x2F;Users&#x2F;michael&#x2F;testdir&#39;</span><br><span class="line"># 然后创建一个目录:</span><br><span class="line">&gt;&gt;&gt; os.mkdir(&#39;&#x2F;Users&#x2F;michael&#x2F;testdir&#39;)</span><br><span class="line"># 删掉一个目录:</span><br><span class="line">&gt;&gt;&gt; os.rmdir(&#39;&#x2F;Users&#x2F;michael&#x2F;testdir&#39;)</span><br></pre></td></tr></table></figure>
<p>把两个路径合成一个时，不要直接拼字符串，而要通过<code>os.path.join()</code>函数，这样可以正确处理不同操作系统的路径分隔符。在Linux/Unix/Mac下，<code>os.path.join()</code>返回这样的字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">part-1&#x2F;part-2</span><br></pre></td></tr></table></figure>
<p>而Windows下会返回这样的字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">part-1\part-2</span><br></pre></td></tr></table></figure>
<p>同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过<code>os.path.split()</code>函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.split(&#39;&#x2F;Users&#x2F;michael&#x2F;testdir&#x2F;file.txt&#39;)</span><br><span class="line">(&#39;&#x2F;Users&#x2F;michael&#x2F;testdir&#39;, &#39;file.txt&#39;)</span><br></pre></td></tr></table></figure>
<p><code>os.path.splitext()</code>可以直接让你得到文件扩展名，很多时候非常方便：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.splitext(&#39;&#x2F;path&#x2F;to&#x2F;file.txt&#39;)</span><br><span class="line">(&#39;&#x2F;path&#x2F;to&#x2F;file&#39;, &#39;.txt&#39;)</span><br></pre></td></tr></table></figure>
<p>这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。</p>
<p>文件操作使用下面的函数。假定当前目录下有一个<code>test.txt</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 对文件重命名:</span><br><span class="line">&gt;&gt;&gt; os.rename(&#39;test.txt&#39;, &#39;test.py&#39;)</span><br><span class="line"># 删掉文件:</span><br><span class="line">&gt;&gt;&gt; os.remove(&#39;test.py&#39;)</span><br></pre></td></tr></table></figure>


<h3 id="shutil模块"><a href="#shutil模块" class="headerlink" title="shutil模块"></a>shutil模块</h3><p>但是复制文件的函数居然在<code>os</code>模块中不存在！原因是复制文件并非由操作系统提供的系统调用。理论上讲，我们通过上一节的读写文件可以完成文件复制，只不过要多写很多代码。</p>
<p>幸运的是<code>shutil</code>模块提供了<code>copyfile()</code>的函数，你还可以在<code>shutil</code>模块中找到很多实用函数，它们可以看做是<code>os</code>模块的补充。</p>
<p>最后看看如何利用Python的特性来过滤文件。比如我们要列出当前目录下的所有目录，只需要一行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [x for x in os.listdir(&#39;.&#39;) if os.path.isdir(x)]</span><br><span class="line">[&#39;.lein&#39;, &#39;.local&#39;, &#39;.m2&#39;, &#39;.npm&#39;, &#39;.ssh&#39;, &#39;.Trash&#39;, &#39;.vim&#39;, &#39;Applications&#39;, &#39;Desktop&#39;, ...]</span><br></pre></td></tr></table></figure>
<p>要列出所有的<code>.py</code>文件，也只需一行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [x for x in os.listdir(&#39;.&#39;) if os.path.isfile(x) and os.path.splitext(x)[1]&#x3D;&#x3D;&#39;.py&#39;]</span><br><span class="line">[&#39;apis.py&#39;, &#39;config.py&#39;, &#39;models.py&#39;, &#39;pymonitor.py&#39;, &#39;test_db.py&#39;, &#39;urls.py&#39;, &#39;wsgiapp.py&#39;]</span><br></pre></td></tr></table></figure>
<p>是不是非常简洁？</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Python的<code>os</code>模块封装了操作系统的目录和文件操作，要注意这些函数有的在<code>os</code>模块中，有的在<code>os.path</code>模块中。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 17 - Python 操作文件和目录</title>
    <url>/2020/python17/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer" />


<p>读写文件是最常见的操作之一，Python内置了读写文件的函数，用法和C语言是类似的。</p>
<p>读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p>
<h3 id="open-函数"><a href="#open-函数" class="headerlink" title="open()函数"></a>open()函数</h3><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>要以读文件的模式打开一个文件对象，使用Python内置的<code>open()</code>函数，传入文件名和标示符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; open(&#39;&#x2F;Users&#x2F;michael&#x2F;test.txt&#39;, &#39;r&#39;)</span><br></pre></td></tr></table></figure>
<p>标示符’r’表示读，这样，我们就成功地打开了一个文件。</p>
<p>如果文件不存在，<code>open()</code>函数就会抛出一个<code>IOError</code>的错误，并且给出错误码和详细的信息告诉你文件不存在：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f&#x3D;open(&#39;&#x2F;Users&#x2F;michael&#x2F;notfound.txt&#39;, &#39;r&#39;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">FileNotFoundError: [Errno 2] No such file or directory: &#39;&#x2F;Users&#x2F;michael&#x2F;notfound.txt&#39;</span><br></pre></td></tr></table></figure>
<p>如果文件打开成功，接下来，调用<code>read()</code>方法可以一次读取文件的全部内容，Python把内容读到内存，用一个<code>str</code>对象表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">&#39;Hello, world!&#39;</span><br></pre></td></tr></table></figure>
<p>最后一步是调用<code>close()</code>方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f.close()</span><br></pre></td></tr></table></figure>
<p>由于文件读写时都有可能产生<code>IOError</code>，一旦出错，后面的<code>f.close()</code>就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用<code>try ... finally</code>来实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    f &#x3D; open(&#39;&#x2F;path&#x2F;to&#x2F;file&#39;, &#39;r&#39;)</span><br><span class="line">    print(f.read())</span><br><span class="line">finally:</span><br><span class="line">    if f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure>
<p>但是每次都这么写实在太繁琐，所以，Python引入了<code>with</code>语句来自动帮我们调用<code>close()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&#39;&#x2F;path&#x2F;to&#x2F;file&#39;, &#39;r&#39;) as f:</span><br><span class="line">    print(f.read())</span><br></pre></td></tr></table></figure>
<p>这和前面的<code>try ... finally</code>是一样的，但是代码更简洁，并且不必手动调用<code>f.close()</code>方法。</p>
<p>调用<code>read()</code>会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用<code>read(size)</code>方法，每次最多读取size个字节的内容。另外，调用<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回<code>list</code>。因此，要根据需要决定怎么调用。</p>
<p>如果文件很小，<code>read()</code>一次性读取最方便；如果不能确定文件大小，反复调用<code>read(size)</code>比较保险；如果是配置文件，调用<code>readlines()</code>最方便：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for line in f.readlines():</span><br><span class="line">    print(line.strip()) # 把末尾的&#39;\n&#39;删掉</span><br></pre></td></tr></table></figure>


<h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>写文件和读文件是一样的，唯一区别是调用<code>open()</code>函数时，传入标识符<code>&#39;w&#39;</code>或者<code>&#39;wb&#39;</code>表示写文本文件或写二进制文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; open(&#39;&#x2F;Users&#x2F;michael&#x2F;test.txt&#39;, &#39;w&#39;)</span><br><span class="line">&gt;&gt;&gt; f.write(&#39;Hello, world!&#39;)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br></pre></td></tr></table></figure>
<p>你可以反复调用<code>write()</code>来写入文件，但是最后务必调用<code>f.close()</code>来关闭文件对象。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用<code>close()</code>方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用<code>close()</code>的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用<code>with</code>语句来得保险：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&#39;&#x2F;Users&#x2F;michael&#x2F;test.txt&#39;, &#39;w&#39;) as f:</span><br><span class="line">    f.write(&#39;Hello, world!&#39;)</span><br></pre></td></tr></table></figure>
<p>要写入特定编码的文本文件，请给<code>open()</code>函数传入<code>encoding</code>参数，将字符串自动转换成指定编码。</p>
<p>细心的同学会发现，以<code>&#39;w&#39;</code>模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新建一个文件）。如果我们希望追加到原文件末尾怎么办？可以传入<code>&#39;a&#39;</code>以追加（append）模式写入。</p>
<p>除<code>&#39;r&#39;</code>、<code>&#39;w&#39;</code>、<code>&#39;a&#39;</code>外还有其他的操作模式，这里所说的操作模式是指要以什么方式打开文件（文本模式或二进制模式）以及做什么样的操作（读、写或追加），具体如下表所示：</p>
<table>
<thead>
<tr>
<th>操作模式</th>
<th>具体含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#39;r&#39;</code></td>
<td>读取 （默认，文件不存在则抛出一个<code>IOError</code>的错误）</td>
</tr>
<tr>
<td><code>&#39;w&#39;</code></td>
<td>写入（文件已存在则覆盖）</td>
</tr>
<tr>
<td><code>&#39;x&#39;</code></td>
<td>写入（文件已存在则抛出异常）</td>
</tr>
<tr>
<td><code>&#39;a&#39;</code></td>
<td>写入（文件已存在则在文件末尾追加新的内容）</td>
</tr>
<tr>
<td><code>&#39;b&#39;</code></td>
<td>二进制模式</td>
</tr>
<tr>
<td><code>&#39;t&#39;</code></td>
<td>文本模式（默认）</td>
</tr>
<tr>
<td><code>&#39;+&#39;</code></td>
<td>更新（既可以读又可以写）</td>
</tr>
</tbody></table>
<h3 id="file-like-Object"><a href="#file-like-Object" class="headerlink" title="file-like Object"></a>file-like Object</h3><p>像<code>open()</code>函数返回的这种有个<code>read()</code>方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要有<code>read()</code>方法就行。</p>
<p><code>StringIO</code>就是在内存中创建的file-like Object，常用作临时缓冲。</p>
<h3 id="打开二进制文件"><a href="#打开二进制文件" class="headerlink" title="打开二进制文件"></a>打开二进制文件</h3><p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用<code>&#39;rb&#39;</code>模式打开文件即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; open(&#39;&#x2F;Users&#x2F;michael&#x2F;test.jpg&#39;, &#39;rb&#39;)</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">b&#39;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&#39; # 十六进制表示的字节</span><br></pre></td></tr></table></figure>


<h3 id="字符编码问题"><a href="#字符编码问题" class="headerlink" title="字符编码问题"></a>字符编码问题</h3><p>要读取非UTF-8编码的文本文件，需要给<code>open()</code>函数传入<code>encoding</code>参数，例如，读取GBK编码的文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; open(&#39;&#x2F;Users&#x2F;michael&#x2F;gbk.txt&#39;, &#39;r&#39;, encoding&#x3D;&#39;gbk&#39;)</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">&#39;测试&#39;</span><br></pre></td></tr></table></figure>
<p>遇到有些编码不规范的文件，你可能会遇到<code>UnicodeDecodeError</code>，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，<code>open()</code>函数还接收一个<code>errors</code>参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; open(&#39;&#x2F;Users&#x2F;michael&#x2F;gbk.txt&#39;, &#39;r&#39;, encoding&#x3D;&#39;gbk&#39;, errors&#x3D;&#39;ignore&#39;)</span><br></pre></td></tr></table></figure>


<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在Python中，文件读写是通过<code>open()</code>函数打开的文件对象完成的。使用<code>with</code>语句操作文件IO是个好习惯。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 年度精选歌单</title>
    <url>/2020/music2019/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="2019-年度精选歌单"><a href="#2019-年度精选歌单" class="headerlink" title="2019 年度精选歌单"></a>2019 年度精选歌单</h3>
    <div id="aplayer-vtZCzTGZ" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="3159878612" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555" data-volume="0.4"
    ></div>

]]></content>
      <categories>
        <category>音乐</category>
      </categories>
      <tags>
        <tag>2019</tag>
        <tag>歌单</tag>
        <tag>音乐</tag>
        <tag>收藏</tag>
      </tags>
  </entry>
  <entry>
    <title>音乐剧 Hamilton punchlines</title>
    <url>/2020/HamiltonPunchlines/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="读-Hamilton-剧本的摘录"><a href="#读-Hamilton-剧本的摘录" class="headerlink" title="读 Hamilton 剧本的摘录"></a>读 Hamilton 剧本的摘录</h2><hr>
<br/>

<blockquote>
<p>A voice saying<br>“Alex, you gotta fend for yourself.”</p>
</blockquote>
<a id="more"></a>

<br/>

<blockquote>
<p>In New York you can be a new man</p>
</blockquote>
<br/>

<blockquote>
<p>When America sings for you<br>Will they know what you overcame?<br>Will they know you rewrote the game?<br>The world will never be the same, oh</p>
</blockquote>
<br/>

<blockquote>
<p>Talk less<br>Smile more<br>Don’t let them know what you’re against or what you’re for</p>
</blockquote>
<br/>

<blockquote>
<p>I am not throwing away my shot!</p>
</blockquote>
<br/>

<blockquote>
<p>I may not live to see our glory!<br>But I will gladly join the fight!</p>
</blockquote>
<br/>

<blockquote>
<p>Raise a glass to freedom<br>Something they can never take away</p>
</blockquote>
<br/>

<blockquote>
<p>There’s nothin’ like summer in the city<br>Someone in a rush next to someone lookin’ pretty</p>
</blockquote>
<br/>

<blockquote>
<p>Look around, look around at how<br>Lucky we are to be alive right now!</p>
</blockquote>
<br/>

<blockquote>
<p>History is happening in Manhattan and we just happen to be<br>In the greatest city in the world!</p>
</blockquote>
<br/>

<blockquote>
<p>You say<br>The price of my love’s not a price that you’re willing to pay</p>
</blockquote>
<br/>


<blockquote>
<p>the elephant is in the room</p>
</blockquote>
<br/>

<blockquote>
<p>Love doesn’t discriminate<br>Between the sinners<br>And the saints</p>
</blockquote>
<br/>

<blockquote>
<p>Death doesn’t discriminate<br>Between the sinners<br>And the saints</p>
</blockquote>
<br/>

<blockquote>
<p>But I’m not afraid<br>I know who I married</p>
</blockquote>
<br/>

<blockquote>
<p>Let me tell you what I wish I’d known<br>When I was young and dreamed of glory:<br>You have no control:<br>Who lives, who dies, who tells your story</p>
</blockquote>
<br/>

<blockquote>
<p>Hercules Mulligan, I need no introduction<br>When you knock me down I get the fuck back up again!</p>
</blockquote>
<br/>

<blockquote>
<p>Oh Philip, you outshine the morning sun</p>
</blockquote>
<br/>

<blockquote>
<p>You won’t be an ocean away<br>You will only be a moment away</p>
</blockquote>
<br/>

<blockquote>
<p>There’s nothing like summer in the city<br>Someone under stress meets someone looking pretty</p>
</blockquote>
<br/>

<blockquote>
<p>I hope this letter finds you in good health</p>
</blockquote>
<br/>

<blockquote>
<p>hate the sin, love the sinner</p>
</blockquote>
<br/>

<blockquote>
<p>Smells like new money, dresses like fake royalty</p>
</blockquote>
<br/>

<blockquote>
<p>Like the scripture says:<br>“Everyone shall sit under their own vine and fig tree<br>And no one shall make them afraid.”</p>
</blockquote>
<br/>

<blockquote>
<p>“You have married an Icarus<br>He has flown too close to the sun.”</p>
</blockquote>
<br/>

<blockquote>
<p>There are moments that the words don’t reach<br>There is suffering too terrible to name</p>
</blockquote>
<br/>

<blockquote>
<p>Best of wives and best of women</p>
</blockquote>
<br/>
]]></content>
      <categories>
        <category>音乐</category>
      </categories>
      <tags>
        <tag>音乐</tag>
        <tag>收藏</tag>
        <tag>音乐剧</tag>
        <tag>艺术</tag>
      </tags>
  </entry>
  <entry>
    <title>音乐剧Hamilton剧本</title>
    <url>/2021/HamiltonPlay/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="音乐剧-Hamilton-剧本"><a href="#音乐剧-Hamilton-剧本" class="headerlink" title="音乐剧 Hamilton 剧本"></a>音乐剧 Hamilton 剧本</h2><br/>

<blockquote>
<p>Hamilton 的剧本，我自己做的标注</p>
</blockquote>
<a id="more"></a>

<br/>

<h4 id="在线预览："><a href="#在线预览：" class="headerlink" title="在线预览："></a>在线预览：</h4>

	<div class="row">
    <embed src="../../../resource/hamilton.pdf" width="100%" height="550" type="application/pdf">
	</div>





<br/>

<h4 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h4><p><a href="https://shikamaru-go.gitee.io/resource/hamilton.pdf">Hamilton.pdf</a></p>
]]></content>
      <categories>
        <category>音乐</category>
      </categories>
      <tags>
        <tag>音乐</tag>
        <tag>收藏</tag>
        <tag>音乐剧</tag>
        <tag>艺术</tag>
      </tags>
  </entry>
</search>
